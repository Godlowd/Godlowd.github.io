<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Operating System 没有安装操作系统,计算机依然可以运行程序 普通用户不能正常使用">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统原理笔记">
<meta property="og:url" content="http://yoursite.com/2020/03/02/OS/index.html">
<meta property="og:site_name" content="Island">
<meta property="og:description" content="Operating System 没有安装操作系统,计算机依然可以运行程序 普通用户不能正常使用">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-02T05:52:32.000Z">
<meta property="article:modified_time" content="2020-05-15T10:44:30.067Z">
<meta property="article:author" content="nullptr">
<meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/03/02/OS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>操作系统原理笔记 | Island</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
  <div class="container use-motion">
    <div class="headband"></div>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Island</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-messages">

    <a href="/message/" rel="section"><i class="fa fa-fw fa-comment"></i>留言板</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Godlowd" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nullptr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Island">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统原理笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-02 13:52:32" itemprop="dateCreated datePublished" datetime="2020-03-02T13:52:32+08:00">2020-03-02</time>
            </span>

          
            <span id="/2020/03/02/OS/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统原理笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/03/02/OS/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/03/02/OS/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><ul>
<li>没有安装操作系统,计算机<strong>依然可以运行程序</strong></li>
<li>普通用户不能正常使用</li>
</ul>
<a id="more"></a>
<h4 id="操作系统功能和定义"><a href="#操作系统功能和定义" class="headerlink" title="操作系统功能和定义"></a>操作系统功能和定义</h4><ol>
<li>进程管理(CPU管理)</li>
</ol>
<ul>
<li>进程控制: 创建,暂停,唤醒,撤销</li>
<li>进程调度: 调度策略,优先级</li>
<li>进程通信: 进程间通信</li>
</ul>
<ol>
<li>内存管理</li>
</ol>
<ul>
<li>内存分配</li>
<li>内存共享</li>
<li>内存保护</li>
<li>虚拟内存</li>
</ul>
<ol>
<li>设备管理</li>
</ol>
<ul>
<li>设备管理和调度</li>
<li>设备无关性</li>
<li>设备传输控制</li>
<li>设备驱动</li>
</ul>
<ol>
<li>文件管理</li>
</ol>
<ul>
<li>存储空间操作</li>
<li>文件操作</li>
<li>目录操作</li>
<li>文件和目录存取权限的管理</li>
</ul>
<h4 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h4><ul>
<li>提供用户<strong>接口</strong></li>
<li>负责为应用程序<strong>分配和调度软硬件资源</strong>, 控制与协调程序并发活动,帮助用户存取等等</li>
</ul>
<h4 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h4><ul>
<li>并发性: 同时处理多个任务的能力</li>
<li>共享性: 为多个并发任务提供资源共享</li>
<li>不确定性: 具有处理随机事件的能力,例如处理终端,自动化处理能力</li>
</ul>
<h4 id="操作系统历史"><a href="#操作系统历史" class="headerlink" title="操作系统历史"></a>操作系统历史</h4><p><strong>用户需求提升</strong>和<strong>硬件技术进步</strong>是操作系统发展两大动力<br><strong>计算机硬件发展</strong>的四个典型阶段:</p>
<ol>
<li>电子管</li>
<li>晶体管</li>
<li>集成电路</li>
<li>大规模集成电路</li>
</ol>
<p><strong>操作系统</strong>发展的四个典型阶段</p>
<p>每一类操作系统是如何<strong>提升CPU/设备利用率的</strong></p>
<ol>
<li>手工</li>
<li>单道批处理系统(批量,自动,单道)<br>将多个作业输入到磁盘形成作业队列<br>操作系统依次自动处理队列中的每个作业<br>外设和CPU交替空闲和忙碌,利用效率低</li>
<li>多道批处理系统(多道,并行(宏观),串行(微观))<br>存放<strong>多道程序</strong><br>缺点:作业处理时间长,交互能力差,运行时间不确定</li>
<li>分时系统</li>
</ol>
<h4 id="分时技术与分时操作系统"><a href="#分时技术与分时操作系统" class="headerlink" title="分时技术与分时操作系统"></a>分时技术与分时操作系统</h4><ul>
<li>中断技术, 通道技术: 专门处理外设与内存之间数据传输的处理机(通道)<br>多终端计算机: <ul>
<li>高性能主机 + 多个终端<ul>
<li>主机:运算,CPU强大,大容量内存</li>
<li>终端: 输入和显示,通过串口线远程连接至主机<br>采用分时技术轮流为每个终端服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>分时技术</strong>:    主机以<strong>很短</strong>的<strong>时间片</strong>为单位,把CPU轮流分给每个终端使用,直到作业全被执行完.由于<strong>时间片</strong>很短,每个终端都能很快重新获得CPU,得到及时响应.</p>
<p><strong>等待周期</strong> = <strong>时间片</strong> $\times$ 终端数量</p>
<h5 id="分时系统的特点"><a href="#分时系统的特点" class="headerlink" title="分时系统的特点"></a>分时系统的特点</h5><ul>
<li>多路调制性:<strong>多用户</strong>联机使用同一台计算机</li>
<li>交互性: 及时响应</li>
<li><p>独占性: 用户感觉独占计算机</p>
</li>
<li><p>大型分时系统的实践:Multics</p>
</li>
</ul>
<h5 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h5><ul>
<li>第一个<strong>实用化</strong>的分时操作系统</li>
<li>实现了操作系统的<strong>可移植性</strong></li>
<li>实现了硬件无关性</li>
<li>引进了特殊文件的概念:<br>把外设看作文件,实现统一管理</li>
</ul>
<h4 id="典型操作系统类型"><a href="#典型操作系统类型" class="headerlink" title="典型操作系统类型"></a>典型操作系统类型</h4><ul>
<li>微机操作系统</li>
<li>多处理机</li>
<li>网络</li>
<li>实时</li>
<li>嵌入式</li>
<li>分布式</li>
</ul>
<h5 id="微机系统"><a href="#微机系统" class="headerlink" title="微机系统"></a>微机系统</h5><p>Control Program Microprocessor </p>
<ul>
<li>良好的层次结构,<strong>BIOS</strong>将操作系统和硬件分隔<br>Mac OSxi</li>
<li>最早使用图形界面和鼠标的操作系统<br>MS DOS</li>
<li>磁盘操作系统</li>
<li>单用户单任务<br>Windows</li>
</ul>
<h5 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h5><p>产生背景:某些任务<strong>优先紧急</strong>处理<br>强调作业完成时限</p>
<h5 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h5><p>约等于实时操作系统,实时OS可以看作嵌入式OS的一个分支</p>
<ul>
<li>软硬件可以裁剪,软硬件一体化,考虑成本造价需求等自己选择硬件和OS.</li>
<li>典型的嵌入式操作系统:Linux,ucOS</li>
</ul>
<h5 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h5><p>在普通操作系统的基础上增加了网络通信和网络服务的功能,常见的操作系统都是网络操作系统UNIX,LINUX,WINDOWS</p>
<ul>
<li>网络资源透明存取</li>
<li>存取控制</li>
</ul>
<h3 id="操作系统评价指标"><a href="#操作系统评价指标" class="headerlink" title="操作系统评价指标"></a>操作系统评价指标</h3><ul>
<li>吞吐率: 单位时间处理信息的能力</li>
<li>响应能力: 从接收数据到输出结果的时间间隔</li>
<li>资源利用率: 设备的使用频度(CPU,内存等等),以更优化的调度和管理方式让CPU尽可能的忙碌.</li>
<li>可移植性:改变硬件环境仍能正常工作的能力(<strong>代码修改量</strong>)</li>
<li>可靠性:发现,诊断和恢复系统故障的能力</li>
</ul>
<h3 id="操作系统逻辑结构"><a href="#操作系统逻辑结构" class="headerlink" title="操作系统逻辑结构"></a>操作系统逻辑结构</h3><ul>
<li>设计逻辑和实现思路</li>
</ul>
<ol>
<li>整体式</li>
<li>层次式</li>
<li>微内核式</li>
</ol>
<h5 id="整体式"><a href="#整体式" class="headerlink" title="整体式"></a>整体式</h5><p>以<strong>模块</strong>为基本单位构建</p>
<p>特点：</p>
<ul>
<li>模块设计，编码，调试独立</li>
<li>模块调度自由</li>
<li>通信多以<strong>全局变量</strong>完成，</li>
</ul>
<p>缺点：</p>
<ul>
<li>信息传递随意，维护和更新困难</li>
</ul>
<h5 id="层次式"><a href="#层次式" class="headerlink" title="层次式"></a>层次式</h5><p>TCP/IP协议栈，越往底层和硬件联系越紧密，越往上层和用户联系越紧密</p>
<p>分层原则：</p>
<ul>
<li>硬件相关——最底层</li>
<li>外部特性——最外层</li>
<li>中间层——调用次序或消息传递顺序</li>
<li>共性的服务——较低层</li>
<li>活跃功能——较低层</li>
</ul>
<p>优点： </p>
<ul>
<li>结构清晰，避免循环调用</li>
<li>整体问题局部化，系统的正确性容易保证</li>
<li>有利于操作系统的扩充，维护和移植</li>
</ul>
<h5 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h5><p>Linux = 内核 + shell + X Windows+ 应用程序<br>宏内核结构<br>将图形,设备驱动,及文件系统全部功能都在内核实现.</p>
<ul>
<li>优点: 减少通信和状态切换开销,运行效率较高</li>
<li></li>
</ul>
<h5 id="微内核-客户-服务器结构"><a href="#微内核-客户-服务器结构" class="headerlink" title="微内核(客户/服务器结构)"></a>微内核(客户/服务器结构)</h5><p>微内核 + 核外服务器</p>
<p>微内核： 提供os最基本的核心功能和服务</p>
<ul>
<li>优点: 内核便于裁剪和移植,稳定性和安全性较高.</li>
<li>实现与硬件紧密相关的处理</li>
<li>实现一些较基本的功能</li>
<li>负责客服和服务器间的通信<br>核外服务器： 完成os的绝大部份服务功能，等待应用程序提出请求</li>
<li>由若干服务器或者进程共同构成</li>
</ul>
<h3 id="CPU的态"><a href="#CPU的态" class="headerlink" title="CPU的态"></a>CPU的态</h3><p>支持OS最基本的硬件结构：</p>
<ol>
<li>CPU</li>
<li>内存</li>
<li>中断</li>
<li>时钟</li>
</ol>
<h3 id="CPU态"><a href="#CPU态" class="headerlink" title="CPU态"></a>CPU态</h3><p>CPU的工作状态，也是一种对资源和指令使用权限的描述</p>
<p>态主要可分为3类：</p>
<ol>
<li>核态（kernel mode), 可访问所有资源，使用所有指令，管理程序或OS内核</li>
<li>用户态(User mode)，可访问部分资源，权限受限，用户程序</li>
<li>管态(Supervisor mode)，介于二者之间</li>
</ol>
<h4 id="用户态和核态的相互转换"><a href="#用户态和核态的相互转换" class="headerlink" title="用户态和核态的相互转换"></a>用户态和核态的相互转换</h4><p>用户态向核态转换：</p>
<ul>
<li>用户请求OS提供服务</li>
<li>发生中断</li>
<li>用户进程产生错误（产生中断）</li>
<li>用户态企图执行特权指令</li>
</ul>
<p>核态向用户态转换：</p>
<ul>
<li>中断返回：IRET</li>
</ul>
<h4 id="硬件和OS对CPU的观察"><a href="#硬件和OS对CPU的观察" class="headerlink" title="硬件和OS对CPU的观察"></a>硬件和OS对CPU的观察</h4><ul>
<li>硬件按照<strong>态</strong>，核态或者用户态，来区分CPU的状态</li>
<li>OS按<strong>进程</strong>来区分CPU的状态，进程A，进程B，还是进程C</li>
</ul>
<h5 id="Intel-CPU的态"><a href="#Intel-CPU的态" class="headerlink" title="Intel CPU的态"></a>Intel CPU的态</h5><ul>
<li>Ring0～Ring3（0为最核心，3为最外层）</li>
<li>程序A访问程序B时需要进行权限的检查，也就是对态的检查，比较DPL和RPL</li>
<li>RPL描述程序段的属性</li>
</ul>
<h4 id="存储程序和数据的部件"><a href="#存储程序和数据的部件" class="headerlink" title="存储程序和数据的部件"></a>存储程序和数据的部件</h4><ul>
<li><p>按照读写的工作方式： </p>
<p>RAM</p>
<p>ROM:固定在主板上,普通用户无法直接更新和拆除</p>
</li>
<li><p>按照与CPU的联系：<br>主存:直接与CPU交换信息<br>辅存:不能直接与CPU交换信息</p>
</li>
</ul>
<h5 id="分级存储系统的工作原理"><a href="#分级存储系统的工作原理" class="headerlink" title="分级存储系统的工作原理"></a>分级存储系统的工作原理</h5><p>CPU读取指令或数据时访问顺序：</p>
<ol>
<li>首先访问高速缓存Cache中的数据，如果需要访问的数据在Cache中，称之为命中</li>
<li>如果没有命中，则CPU会到主存中访问，如果没有，则MISS</li>
<li>再到辅存中访问，如果辅存中也没有，则称之为缺页</li>
</ol>
<h3 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h3><ul>
<li>CPU对突发外部事件反应过程或机制</li>
<li>CPU收到<strong>外部信号</strong>(中断信号),停止当前工作,转去处理该<strong>外部信号</strong>,处理完毕之后回到原来工作的<strong>中断处</strong>(断点)继续原来的工作</li>
<li>引入中断的目的<ol>
<li>实现并发活动</li>
<li>实现实时处理</li>
<li>故障自动处理</li>
</ol>
</li>
</ul>
<h4 id="中断的一些基本概念"><a href="#中断的一些基本概念" class="headerlink" title="中断的一些基本概念"></a>中断的一些基本概念</h4><p>中断源: 引起系统中断的事件</p>
<p>断点: 将要执行的下一指令的地址:<strong>CS:IP</strong></p>
<p>现场: 程序运行所依赖的信息集合.</p>
<p>中断类型: 强迫性中中断和自愿中断</p>
<ul>
<li>强迫性: 程序没有预期,例如: <strong>I/O</strong>,<strong>外部中断</strong></li>
<li>自愿中断: 程序有预期的,例如: <strong>执行访管指令</strong></li>
</ul>
<p>外中断(<strong>中断</strong>)和内中断(<strong>俘获</strong>)</p>
<ul>
<li>外中断:由CPU外部事件引起, 例如:  <strong>I/O</strong>, 外部事情</li>
<li>内中断: 由CPU内部事件引起. 例如: 访管中断,程序中断</li>
</ul>
<p>外中断: 不可屏蔽和可屏蔽</p>
<ul>
<li>不可屏蔽中断: 中断的原因很紧要,CPU必须响应</li>
<li>可屏蔽中断: 中断的原因不很紧要,CPU可以不必响应</li>
</ul>
<p>断点: 程序将要执行的下一个指令的地址</p>
<p>现场: 程序正确运行所依赖的信息集合</p>
<ul>
<li>相关寄存器的内容</li>
</ul>
<p>现场的<strong>两个</strong>处理过程</p>
<ul>
<li>现场的保护: 进入中断服务程序之前,将寄存器的值入栈</li>
<li>现场的恢复: 退出中断服务程序之后,出栈</li>
</ul>
<h4 id="中断响应过程"><a href="#中断响应过程" class="headerlink" title="中断响应过程"></a>中断响应过程</h4><ol>
<li>识别中断源</li>
<li>保护断点和现场</li>
<li>装入<strong>中断服务程序的入口地址</strong></li>
<li>进入中断服务程序</li>
<li>恢复现场和断点</li>
<li>中断返回(<strong>IRET</strong>)</li>
</ol>
<h4 id="中断响应的实质"><a href="#中断响应的实质" class="headerlink" title="中断响应的实质"></a>中断响应的实质</h4><ul>
<li>交换指令执行地址的过程(CS:IP发生变化,)</li>
<li>交换了CPU的态:主程序在<strong>用户态</strong>完成,中断程序在<strong>核态</strong>完成</li>
<li>工作:现场保护和恢复.通信</li>
</ul>
<h2 id="操作系统用户界面"><a href="#操作系统用户界面" class="headerlink" title="操作系统用户界面"></a>操作系统用户界面</h2><ul>
<li>重点/难点</li>
</ul>
<ol>
<li>操作系统启动过程</li>
<li>操作系统生成过程</li>
<li>系统调用机制</li>
</ol>
<h3 id="操作系统启动过程"><a href="#操作系统启动过程" class="headerlink" title="操作系统启动过程"></a>操作系统启动过程</h3><ol>
<li>操作系统启动过程<br>实模式和保护模式</li>
</ol>
<ul>
<li><p>实模式(REAL MODE,刚刚开机)</p>
</li>
<li><p>程序按照8086寻址方法,1MB空间</p>
</li>
<li><p>前面640K [00000~9FFFF]: 基本内存</p>
</li>
<li><p>中间128K [A0000~BFFFF]: 显卡显存</p>
</li>
<li><p>末尾256K [C0000~FFFFF]: BIOS</p>
<ul>
<li>显卡BIOS<ul>
<li>IDE控制器BIOS</li>
<li>系统<strong>BIOS</strong>(重点)</li>
</ul>
</li>
<li>寻址方式: 物理地址(20位) = 段地址(16位):偏移地址(16位)</li>
<li>CPU单任务运行</li>
</ul>
</li>
<li><p>保护模式(内存模式,PROTECT MODE)</p>
<ul>
<li>寻址方式: 段(<strong>32位</strong>)和偏移量(<strong>32位</strong>),</li>
<li>可寻址<strong>4GB</strong>空间</li>
<li>段页式寻址机制</li>
<li>虚拟地址,进程,封闭空间</li>
<li>CPU支持多任务</li>
<li>应用程序和操作系统的运行环境都被<strong>保护</strong>(保护了内存)</li>
</ul>
</li>
</ul>
<h4 id="系统BIOS"><a href="#系统BIOS" class="headerlink" title="系统BIOS"></a>系统BIOS</h4><ul>
<li><p>系统启动配置</p>
<ul>
<li>基本设备IO服务</li>
<li>系统加电自检和启动</li>
</ul>
<p>按下<strong>PowerOn</strong>或者Reset执行第一条指令</p>
<ul>
<li>执行FFFF0处的指令: <strong>JUMP POST</strong> ,跳转到<strong>加电自检</strong>处.</li>
</ul>
<p>加电自检Power On Self-Test</p>
<ul>
<li>初始化基本硬件(CPU,内存,显卡)</li>
<li>自检正常不提示,错误则喇叭提示</li>
</ul>
<p>加电自检完成后:</p>
<ul>
<li>查找BIOS,调用显卡BIOS</li>
<li>查找其他设备执行相应设备的BIOS</li>
<li>显示启动画面</li>
<li>读入OS,OS接管计算机 </li>
</ul>
</li>
</ul>
<h4 id="主启动记录"><a href="#主启动记录" class="headerlink" title="主启动记录"></a><a href="MBR">主启动记录</a></h4><ul>
<li>存放在硬盘/软盘的首扇区<ul>
<li>存放和OS启动的相关信息,如路径,需要的参数等</li>
<li>512MB</li>
<li>结束于0xAA55H</li>
</ul>
</li>
</ul>
<h5 id="MBR-硬盘分区-格式化"><a href="#MBR-硬盘分区-格式化" class="headerlink" title="MBR/硬盘分区/格式化"></a>MBR/硬盘分区/格式化</h5><p>硬盘的<strong>第一个扇区</strong>存放MBR, 即主启动扇区.剩下的分区的首扇区记录特殊的内容,称为<strong>分区启动信息</strong></p>
<p>首扇区的最前面也有一块特殊的内容,称之为<a href="PBR">主启动扇区</a> , 用于启动操作系统和加载操作系统</p>
<h6 id="BIOS和MBR程序运行过程"><a href="#BIOS和MBR程序运行过程" class="headerlink" title="BIOS和MBR程序运行过程"></a>BIOS和MBR程序运行过程</h6><ol>
<li>POST $\rightarrow$ CMOS设置(硬盘启动) $\rightarrow$  读取MBR $\rightarrow$ 控制权交给MBR</li>
<li>MBR读取<a href="Partion Table">分区表</a> $\rightarrow$ 找到<a href="Active Partion">活动分区</a> , 并确认其他分区都是不活动分区 $\rightarrow$ 读取活动分区的<a href="分区引导记录PBR">第一个分区</a> $\rightarrow$ 加载到内存</li>
<li>PBR继续控制后面的引导过程</li>
</ol>
<h3 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h3><ul>
<li>启动过程: 从<strong>加电</strong> 到<strong>用户工作环境</strong>准备好的过程</li>
</ul>
<ol>
<li>初始引导</li>
<li>核心初始化</li>
<li>系统初始化</li>
</ol>
<h4 id="初始引导"><a href="#初始引导" class="headerlink" title="初始引导"></a>初始引导</h4><ul>
<li><p>把OS核心(以文件的方式存在在硬盘上)装入内存,并使之开始工作接管操作系统</p>
<ul>
<li><p>加点,JUMP POST  </p>
</li>
<li><p>BIOS中的启动程序运行</p>
</li>
</ul>
<p>启动程序: 读取<a href="0面0道第1扇区">MBR</a>的内容,加载MBR中的引导程序</p>
<p>引导程序: 根据相关参数,读取硬盘指定位置的文件到内存</p>
<p>加载硬盘上的OS内核,并初始化基本参数</p>
</li>
</ul>
<h4 id="核心初始化"><a href="#核心初始化" class="headerlink" title="核心初始化"></a>核心初始化</h4><ul>
<li>OS内核初始化系统的核心数据</li>
<li>各种寄存器的初始化</li>
<li>存储系统和页表的初始化</li>
<li>核心进程的构建</li>
</ul>
<h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><ul>
<li>为用户使用系统做准备,使系统处于待命状态</li>
</ul>
<h4 id="Windows启动"><a href="#Windows启动" class="headerlink" title="Windows启动"></a>Windows启动</h4><ol>
<li>POST</li>
</ol>
<ul>
<li>加电吼BIOS启动主机自检</li>
</ul>
<ol>
<li>初始引导</li>
</ol>
<ul>
<li>BIOS从MBR读入<strong>引导程序</strong>, 装入内存的特定位置</li>
<li>引导程序启动DOS7.0,调入操作系统核心</li>
<li>WINDOWS接管系统</li>
</ul>
<ol>
<li>核心初始化</li>
</ol>
<ul>
<li>资源状态,核心数据初始化</li>
</ul>
<ol>
<li>系统初始化</li>
</ol>
<ul>
<li>GUI界面生成, 系统处于待命/消息接受状态</li>
</ul>
<h3 id="操作系统生成"><a href="#操作系统生成" class="headerlink" title="操作系统生成"></a>操作系统生成</h3><ul>
<li>满足特定硬件环境和用户需要，<strong>组装</strong>和<strong>构建</strong>操作系统的过程</li>
</ul>
<h4 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h4><ul>
<li>根据硬件环境/用户配置功能模块和构造参数</li>
<li><strong><a href="build">构建</a>OS的映像</strong></li>
</ul>
<h4 id="OS生成的前提"><a href="#OS生成的前提" class="headerlink" title="OS生成的前提"></a>OS生成的前提</h4><ul>
<li>OS由可拆装模块构成</li>
<li>有交互式配置工具（改变现有参数）</li>
<li>有映像<a href="build">构建</a>工具，将第二步获得的源代码编译</li>
</ul>
<h5 id="LINUX"><a href="#LINUX" class="headerlink" title="LINUX"></a>LINUX</h5><ol>
<li><p>获取Linux源代码</p>
</li>
<li><p>选择和启动内核配置程序</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<ol>
<li>根据需要配置内核模块和参数</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Loadable module support	//设置对可加载模块的支持</span><br><span class="line">Processor <span class="built_in">type</span> and features	//设置CPU类型</span><br><span class="line">General setup	//对普通属性的一些设置</span><br><span class="line">Parallel port support //并口支持</span><br><span class="line">Plug and Play configuration //即插即用配置</span><br><span class="line">Block devices	//块设备支持的选项</span><br></pre></td></tr></table></figure>
<ol>
<li>重新编译新的内核</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make dep	//生成依赖dependency信息</span><br><span class="line">make clean	//清除旧的编译结果</span><br><span class="line">make bzImage	//二进制文件</span><br></pre></td></tr></table></figure>
<ol>
<li>编译和安装新的模块</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make modules</span><br><span class="line">make modules install	//模块被编译且安装到/usr/lib/内核版本号目录下</span><br></pre></td></tr></table></figure>
<ol>
<li>启动新内核</li>
</ol>
<h3 id="OS用户界面"><a href="#OS用户界面" class="headerlink" title="OS用户界面"></a>OS用户界面</h3><ul>
<li>OS提供给用户控制计算机的机制，又称用户接口</li>
</ul>
<p>用户界面的分类：</p>
<ul>
<li>操作界面</li>
<li>系统调用:系统功能调用,程序界面</li>
</ul>
<h4 id="操作界面"><a href="#操作界面" class="headerlink" title="操作界面"></a>操作界面</h4><ul>
<li><p>图形用户接口（GUI,Graphic User Interface）</p>
<p>包括窗口，图标，菜单，按钮，鼠标</p>
</li>
<li><p>键盘命令（COMMAND)</p>
<ul>
<li>在控制台下接受键盘输入的命令</li>
<li>类型： 普通命令，批处理程序，shell</li>
</ul>
</li>
</ul>
<h4 id="Shell脚本编程"><a href="#Shell脚本编程" class="headerlink" title="Shell脚本编程"></a>Shell脚本编程</h4><p><a href="Script">脚本</a>通过类似程序的方式执行具有一定逻辑顺序的命令序列完成较复杂的功能和人机交互</p>
<ul>
<li>脚本程序保存在<strong>文本文件</strong>中</li>
<li>脚本程序是Shell命令语句的集合</li>
</ul>
<p>mkdir:创建路径<br>ldconfig:使配置文件生效<br>rm: 删除文件<br>-rf(参数)表示删除文件夹中的一个子目录</p>
<ul>
<li>执行Shell脚本文件需要具有<a href="x">可执行属性</a><br><code>Chmod + x MyScript.sh</code>来添加可执行属性</li>
</ul>
<h5 id="运行脚本程序的三个方法"><a href="#运行脚本程序的三个方法" class="headerlink" title="运行脚本程序的三个方法"></a>运行脚本程序的三个方法</h5><ol>
<li>直接运行(使用缺省版本的Shell运行)</li>
<li>使用某个特定版本的Shell执行脚本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash first_script</span><br></pre></td></tr></table></figure>
<ul>
<li>指定一个特定版本的shell版本(此例是<strong>bash</strong>)</li>
<li>逐行执行脚本中的命令</li>
<li>当脚本文件中的命令依次执行完毕,临时子shell<strong>自动结束运行</strong>,返回用户原来使用的shell</li>
</ul>
<ol>
<li>在脚本文件<strong>首行</strong>指定shell</li>
</ol>
<ul>
<li>在脚本文件开头增加一行``#!/bin/bash —#!必须顶格,后面接shell全路径</li>
<li>可以从/etc/shell获知所有可用shell及其绝对路径</li>
</ul>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul>
<li>操作系统<strong>内核</strong>为应用程序提供的<strong>服务</strong>/<strong>函数</strong></li>
</ul>
<p>特点: </p>
<ol>
<li>一般涉及核心资源或硬件的操作</li>
<li>运行于核态</li>
<li>每个系统调用具有<strong>唯一的编号</strong></li>
<li>调用过程中会产生<strong>中断</strong>.自愿中断</li>
</ol>
<h5 id="Linux利用INT-80H中断实现系统调用"><a href="#Linux利用INT-80H中断实现系统调用" class="headerlink" title="Linux利用INT 80H中断实现系统调用"></a>Linux利用INT 80H中断实现系统调用</h5><ul>
<li>利用<strong>EAX寄存器</strong>存放系统调用的编号</li>
</ul>
<h5 id="隐式系统调用"><a href="#隐式系统调用" class="headerlink" title="隐式系统调用"></a>隐式系统调用</h5><ul>
<li>类似API函数</li>
<li>在高级语言中使用</li>
<li>在系统内部转换为包含<strong>INT 80H</strong>的指令,执行相应的系统调用</li>
</ul>
<h5 id="Linux系统调用的工作原理"><a href="#Linux系统调用的工作原理" class="headerlink" title="Linux系统调用的工作原理"></a>Linux系统调用的工作原理</h5><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><ul>
<li>重点掌握<strong>线程</strong>,<strong>同步和P-V操作</strong>, <strong>Windows和Linux同步机制</strong>,<strong>进程通信</strong></li>
</ul>
<p>OS区别与应用软件最核心的功能在于OS有进程管理功能和内存管理功能，如果一个应用软件具有上述两个功能我们可以把他看做一个OS</p>
<h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><h4 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h4><ul>
<li>程序在并发环境中的问题:</li>
</ul>
<ol>
<li>运行过程不确定,一个程序什么时候暂停什么时候继续,程序员无法控制.完全由操作系统控制</li>
<li>结果不可再现.可能受到干扰,干扰的结果不可确定<br>解决方案: 对运行过程施加相互约束</li>
</ol>
<ul>
<li>新的概念:进程<br>描述和管理程序<strong>运行过程</strong><br>程序在某个数据集合上的<strong>一次</strong> <strong>运行活动</strong></li>
<li>数据集合: 软/硬件环境,多个进程共存/共享的环境</li>
<li>进程的特性:</li>
</ul>
<ol>
<li>动态性<br>进程是程序的一次执行过程,动态地产生/消亡</li>
<li>并发性<br>进程同其他进程一起向前推进</li>
<li>异步性<br>进程按照各自的速度向前推进</li>
<li>独立性<br>进程是OS分配资源和调度CPU的单位</li>
</ol>
<h6 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="　进程和程序的区别"></a>　进程和程序的区别</h6><ul>
<li>静态和动态</li>
</ul>
<ol>
<li>进程是动态的:程序的一次执行过程</li>
<li>程序是静态的:一组指令的有效集合</li>
</ol>
<ul>
<li>暂存和长存</li>
</ul>
<ol>
<li>进程是暂存的: 在<strong>内存</strong>上驻留</li>
<li>程序是长存的: 在介质上长期保存</li>
</ol>
<ul>
<li>程序和进程的对应<br>一个程序可能有多个进程</li>
</ul>
<h5 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h5><ul>
<li>按照使用资源的权限</li>
</ul>
<ol>
<li>系统进程:指系统内核相关和进程</li>
<li>用户进程: 指运行于用户态的进程</li>
</ol>
<ul>
<li>按对CPU的依赖性</li>
</ul>
<ol>
<li>偏CPU进程: 计算型进程: 如科学计算等</li>
<li>偏I/O进程: 侧重于I/O的进程</li>
</ol>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul>
<li>运行状态(Running)<br>进程已经占有CPU,在CPU上运行,对于大多数计算机来说只有一个CPU所以只有一个进程能够真正的占用CPU</li>
<li>就绪状态(Ready)<br>具备运行条件,但由于<strong>无CPU</strong>,暂时不能运行</li>
<li>阻塞状态(Block)或等待状态(Wait)<br>因为等待某项服务完成或信号不能运行的状态,如等待: 系统调用, I/O操作, 合作进程信号</li>
</ul>
<h5 id="支持挂起-suspend-和解挂-resume-操作"><a href="#支持挂起-suspend-和解挂-resume-操作" class="headerlink" title="支持挂起(suspend)和解挂(resume)操作"></a>支持挂起(suspend)和解挂(resume)操作</h5><ul>
<li>挂起: 用户或者OS将进程有意暂停</li>
<li>解挂: 将挂起的进程继续</li>
<li>阻塞: 活动阻塞(正常阻塞)和静止阻塞(阻塞时挂起)</li>
<li>就绪: 活动就绪(正常就绪)和静止就绪(就绪时挂起)</li>
</ul>
<h5 id="进程状态的变迁"><a href="#进程状态的变迁" class="headerlink" title="　进程状态的变迁"></a>　进程状态的变迁</h5><p>进程的状态可以依据一定的条件相互转化．</p>
<ol>
<li><p>就绪$ \rightarrow$ 运行<br>进程调度</p>
<ol>
<li>运行$ \rightarrow$ 就绪<br>时间片到了,或者优先级更高的进程抢占了CPU</li>
<li>运行$ \rightarrow$ 阻塞<br>请求OS提供服务,等待某个信号的到来</li>
<li>阻塞$ \rightarrow$ 就绪<br>等待的服务完成 了,等待的信号到来了</li>
</ol>
<h4 id="进程控制块-Process-Control-Block"><a href="#进程控制块-Process-Control-Block" class="headerlink" title="进程控制块(Process Control Block)"></a>进程控制块(Process Control Block)</h4><ul>
<li>描述进程状态,资源,和相关进程关系的<strong>数据结构</strong></li>
<li>PCB是进程的<strong>标志</strong></li>
<li>创建进程时创建PCB,进程撤销后PCB同时撤销</li>
</ul>
</li>
</ol>
<p>进程= 程序 + PCB. 程序包含代码和数据</p>
<h6 id="PCB的数据结构"><a href="#PCB的数据结构" class="headerlink" title="PCB的数据结构"></a>PCB的数据结构</h6><ol>
<li>name(ID): 进程名称,标识符</li>
<li>status: 状态</li>
<li>next: 指向下一个PCB的指针</li>
<li>start_addr: 程序地址</li>
<li>priority: 优先级</li>
<li>cpu_status: 现场保留区(堆栈)</li>
<li>comm_info: 进程通信</li>
<li>process_family: 家族</li>
<li>own_resource: 资源</li>
</ol>
<h5 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h5><ul>
<li>进程的上下文:Context,进程的运行环境,CPU环境<br>进程的切换过程</li>
<li>换入进程的上下文进入CPU,从<strong>栈</strong>上读入,同时更新寄存器的信息</li>
<li>换出进程的上下文离开CPU,保存到<strong>栈</strong>中,将来CPU重新读取进程的时候就从栈上读取</li>
</ul>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ul>
<li>进程生存期间对其全部行为的控制</li>
</ul>
<p>四个典型控制行为: </p>
<ol>
<li>创建进程</li>
<li>撤销进程</li>
<li>阻塞进程</li>
<li>唤醒进程</li>
</ol>
<h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><ul>
<li>功能: 创建一个具有指定标识的进程</li>
<li>参数: 进程标识,优先级,进程起始地址,CPU初始状态,资源清单</li>
</ul>
<h6 id="创建进程的过程"><a href="#创建进程的过程" class="headerlink" title="创建进程的过程"></a>创建进程的过程</h6><ol>
<li>创建一个空的PCB</li>
<li>获得并赋予进程标识符ID</li>
<li>为进程分配空间</li>
<li>初始化PCB的成员变量</li>
<li>插入相应的进程队列(新进程插入就绪队列)<br>我们总是默认新创建的进程是<strong>就绪的</strong> ,只要给他CPU立刻就可以运行</li>
</ol>
<h4 id="进程撤销"><a href="#进程撤销" class="headerlink" title="进程撤销"></a>进程撤销</h4><ul>
<li>功能: 撤销一个指定的进程,收回进程所占有的资源,撤销该进程的PCB</li>
<li>撤销进程的时机/事件</li>
</ul>
<ol>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ol>
<ul>
<li>参数: 被撤销的进程ID</li>
</ul>
<h6 id="撤销的过程"><a href="#撤销的过程" class="headerlink" title="撤销的过程"></a>撤销的过程</h6><ol>
<li>在PCB队列中检索出该PCB</li>
<li>获取该进程的状态</li>
<li>若该进程处在运行态,立即终止该进程<br>这里我们需要注意,在OS中,一个操作系统可能有<strong>父进程</strong>也可能有<strong>子进程</strong>,如果要被撤销的进程存在<strong>子进程</strong>,那么我们需要先撤销他的<strong>子进程</strong>(递归过程)</li>
<li>释放进程所占有的资源</li>
<li>将进程从PCB队列移除</li>
</ol>
<h5 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h5><ul>
<li>功能: 停止进程的执行.变为阻塞</li>
<li>阻塞的时间/事件</li>
</ul>
<ol>
<li>请求系统服务:由于某种原因,OS不能立即满足进程的要求</li>
<li>启动某种操作: 进程启动某种操作,阻塞等待该进程执行完毕</li>
<li>新数据尚未到达: A进程需要获得B进程的<strong>中间结果</strong> A进程等待</li>
<li>无新工作可做: 进程完成任务后,<strong>自我阻塞</strong> 等待新任务到达</li>
</ol>
<ul>
<li>参数: <strong>阻塞原因</strong>, 不同的阻塞原因构建不同的阻塞队列</li>
</ul>
<h5 id="阻塞的实现"><a href="#阻塞的实现" class="headerlink" title="阻塞的实现"></a>阻塞的实现</h5><ol>
<li>停止运行</li>
<li>将PCB<strong>运行态</strong>改为<strong>阻塞态</strong></li>
<li>插入相应原因的阻塞队列</li>
<li>转调度程序</li>
</ol>
<h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><ul>
<li>功能: 唤醒处于<strong>阻塞队列</strong>当中的某个进程</li>
<li>参数: 被唤醒进程的ID</li>
<li>引起唤醒的时机/事件</li>
</ul>
<ol>
<li>系统服务由不满到满足</li>
<li>I/O完成</li>
<li>新数据到达</li>
<li>进程提出新请求(服务)</li>
</ol>
<h4 id="进程控制原语"><a href="#进程控制原语" class="headerlink" title="进程控制原语"></a>进程控制原语</h4><ul>
<li>由若干指令构成的具有特定功能的函数</li>
<li>具有<strong>原子性</strong>,操作不可分割,要么执行成功,要么执行失败,中途不可停下</li>
</ul>
<p>进程控制原语:</p>
<ol>
<li>创建</li>
<li>撤销</li>
<li>阻塞</li>
<li>唤醒</li>
</ol>
<h3 id="Windows控制进程"><a href="#Windows控制进程" class="headerlink" title="Windows控制进程"></a>Windows控制进程</h3><ul>
<li>创建进程的方法: 点击图标,启动/创建进程</li>
</ul>
<h3 id="Linux进程控制"><a href="#Linux进程控制" class="headerlink" title="Linux进程控制"></a>Linux进程控制</h3><ul>
<li>创建进程fork(),返回一个pid_t的整形值<br>例如,<code>pid_t pid = fork()</code></li>
<li>新建进程是当前进程的<strong>子进程</strong>,在Linux中所有的进程都具有家族关系</li>
<li>父进程与子进程<br>父进程: fork()的调用者<br>子进程: 新建的进程</li>
<li>子进程是父进程的复制,具有和父进程相同的代码,数据,堆栈,差别在于<strong>ID</strong>号不一样,与时间有关的信息不一样</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	fork();</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在屏幕上会输出两个Hello World的字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"How are you\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时在屏幕上输出一行<code>Hello World</code>与一行<code>How are you</code>.<br>在子进程中,<code>pid=0</code>,在父进程中<code>pid&gt;0</code>(子进程ID),如果执行出错,返回-1<br>但是父进程,子进程是<strong>并发的</strong>,所以字符串输出顺序<strong>不确定</strong>.不会无限循环和递归创建子进程.</p>
<h4 id="子进程和父进程的并发"><a href="#子进程和父进程的并发" class="headerlink" title="子进程和父进程的并发"></a>子进程和父进程的并发</h4><p>当父进程中的<code>pid = fork()</code>指令执行时,复制相同的代码到子进程.<code>fork()</code>指令之前的指令<strong>不再执行</strong>,从指令后面的语句并发.</p>
<h4 id="fork函数的实现"><a href="#fork函数的实现" class="headerlink" title="fork函数的实现"></a>fork函数的实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span></span></span><br><span class="line"><span class="function"><span class="params">	struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="keyword">int</span> do_fork&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = alloc_task_struct();<span class="comment">//分配存放位置的内存</span></span><br><span class="line">    ......</span><br><span class="line">    copy_files(clone_flags,p);</span><br><span class="line">    copy_fs(clone_flags,p);</span><br><span class="line">    copy_mm(clone_flags,p);<span class="comment">//拷贝进程所有信息</span></span><br><span class="line">    ......</span><br><span class="line">    wake_up_process(p);<span class="comment">//唤醒进程,挂入可执行队列等待被调度</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Linux启动以后的第一个进程是<strong>init进程</strong>,所有其他进程都是init的子孙</li>
</ul>
<h4 id="exec函数簇"><a href="#exec函数簇" class="headerlink" title="exec函数簇"></a>exec函数簇</h4><ul>
<li>装入一个<strong>指定的可执行程序</strong>运行</li>
<li><strong>使子进程具有和父进程完全不同的新功能</strong></li>
</ul>
<p>步骤:</p>
<ul>
<li>根据文件名找到相应的可执行程序</li>
<li>将可执行程序的内容填入子进程的地址空间</li>
<li>进入新进程执行且不再返回</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><ul>
<li>由CPU可以直接运行的实体,程序内部的执行路径</li>
<li>一个进程可以创建多个线程</li>
<li>多个线程<strong>共享</strong>CPU可以实现并发运行</li>
</ul>
<ul>
<li>CreateThread()<br>把一个函数创建为一个线程</li>
</ul>
<h5 id="单线程程序和多线程程序"><a href="#单线程程序和多线程程序" class="headerlink" title="单线程程序和多线程程序"></a>单线程程序和多线程程序</h5><ul>
<li>单线程: 整个进程只有一个线程,Windows程序默认只有一个线程(主线程:main线程)</li>
<li>多线程:整个进程至少有两个线程,<strong>主线程</strong>和<strong>至少一个用户线程</strong></li>
</ul>
<h4 id="线程典型应用场景"><a href="#线程典型应用场景" class="headerlink" title="线程典型应用场景"></a>线程典型应用场景</h4><ol>
<li>程序的多个功能需要并发运行<br>例如同时画圆和画方, 暴风影音(在线看电影)(视频解码,音频解码,网络接收)<br>为每一个功能创建为一个线程,从而实现多功能的并发</li>
<li>提高<strong>窗口程序</strong>的交互性</li>
<li>需要改善程序结构的地方</li>
<li>多核CPU上的应用</li>
</ol>
<h5 id="创建线程的补充说明"><a href="#创建线程的补充说明" class="headerlink" title="创建线程的补充说明"></a>创建线程的补充说明</h5><ul>
<li>Win32库创建线程: CreateThread(线程函数,参数)</li>
<li>MFC创建线程: AfxBeginThread(线程函数,参数)</li>
<li>创建远程线程: CreateRemoteThread(进程,线程函数,参数)<strong>这个创建的线程不是在当前控制的进程中</strong></li>
<li>Linux创建线程:pthread_create(线程函数,参数)</li>
</ul>
<h3 id="临界区和锁"><a href="#临界区和锁" class="headerlink" title="临界区和锁"></a>临界区和锁</h3><h4 id="临界资源和临界区"><a href="#临界资源和临界区" class="headerlink" title="临界资源和临界区"></a>临界资源和临界区</h4><ul>
<li>临界资源(Critical Resource): 一次只允许<strong>一个进程</strong>独占访问的资源</li>
<li><p>临界区(Critical Section): 进程中访问临界资源的<strong>程序段</strong></p>
</li>
<li><p>临界区和临界资源的访问特点:</p>
<ul>
<li>具有排他性</li>
<li>并发进程不能<strong>同时进入</strong>临界区</li>
</ul>
</li>
</ul>
<h5 id="设计临界区访问机制的四个原则"><a href="#设计临界区访问机制的四个原则" class="headerlink" title="设计临界区访问机制的四个原则"></a>设计临界区访问机制的四个原则</h5><ul>
<li>忙则等待: 当临界区忙时,其他进程必须在临界区外等待</li>
<li>空闲让进: 当无进程处于临界区时,任何有权进程可以进入临界区</li>
<li>有限等待: 进程进入临界区的请求应该在<strong>有限时间</strong>内得到满足</li>
<li>让权等待: 等待进程放弃CPU,(让其他进程有机会得到CPU)</li>
</ul>
<h5 id="临界区的大小设置"><a href="#临界区的大小设置" class="headerlink" title="临界区的大小设置"></a>临界区的大小设置</h5><p>临界区既不能设置的<strong>过大</strong>,也不能设置的<strong>过小</strong></p>
<p>设置的过大程序等待的时间会变长,过小则达不到设置临界区的目的</p>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><ul>
<li>基本原理: 设置一个标志”S”，表明临界资源<strong>可用</strong>或者<strong>不可用</strong><ol>
<li>进入临界区之前检查标志是否<strong>可用</strong></li>
<li>如果不可用状态,进程在临界区之外<strong>等待</strong></li>
<li>如果可用,访问临界资源,并且设置标志为<strong>不可用</strong></li>
<li>退出临界区时将标志设为可用</li>
</ol>
</li>
</ul>
<h5 id="上锁操作"><a href="#上锁操作" class="headerlink" title="上锁操作"></a>上锁操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LOCK(S)		<span class="comment">//上锁操作</span></span><br><span class="line">&#123;</span><br><span class="line">    test: <span class="keyword">if</span>(S==<span class="number">0</span>)	</span><br><span class="line">        <span class="keyword">goto</span> test;	<span class="comment">//测试锁标志,内部循环</span></span><br><span class="line">    	<span class="keyword">else</span> <span class="comment">//S==1</span></span><br><span class="line">            S=<span class="number">0</span>;	<span class="comment">//上锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="开锁操作"><a href="#开锁操作" class="headerlink" title="开锁操作"></a>开锁操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UnLock(S)</span><br><span class="line">&#123;</span><br><span class="line">    S = <span class="number">1</span>;	<span class="comment">//开锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>开锁原语</strong></p>
<h5 id="锁机制访问临界区"><a href="#锁机制访问临界区" class="headerlink" title="锁机制访问临界区"></a>锁机制访问临界区</h5><ol>
<li>初始化锁状态S=1(可用)</li>
<li>进入临界区之前执行<strong>上锁</strong>操作</li>
<li>退出临界区之后执行<strong>开锁</strong>操作</li>
</ol>
<p>锁机制是否满足四个设计原则?</p>
<p>不满足让权等待</p>
<h4 id="同步和P-V操作-重点"><a href="#同步和P-V操作-重点" class="headerlink" title="同步和P-V操作(重点)"></a>同步和P-V操作(重点)</h4><h5 id="同步和互斥的概念"><a href="#同步和互斥的概念" class="headerlink" title="同步和互斥的概念"></a>同步和互斥的概念</h5><p>进程的<strong>互斥</strong>关系: 多个进程由于共享了独占性资源,必须协调各进程对资源的存取顺序,确保没有任何两个或者以上的进程同时进行<strong>存取操作</strong></p>
<ul>
<li>互斥和资源共享相关</li>
<li>资源: 临界资源</li>
<li>存取操作区域: 临界区<br>进程的<strong>同步</strong>关系: 若干<strong>合作进程</strong>为了完成一个共同的任务,需要相互协调运行步伐,<strong>一个进程</strong>开始某个操作<strong>之前</strong>,必须要求<strong>另一个进程</strong>已经完成了某个操作,否则前面的进程只能<strong>等待</strong></li>
<li>合作关系的另一种解释: 合作进程中的某些操作之间需要满足某种<strong>先后关系</strong>或某个操作能否进程需要满足某个<strong>前提条件</strong>,否则只能等待</li>
<li>互斥关系属于特殊的同步关系</li>
</ul>
<h5 id="P-V操作的概念"><a href="#P-V操作的概念" class="headerlink" title="P-V操作的概念"></a>P-V操作的概念</h5><h6 id="信号灯的概念"><a href="#信号灯的概念" class="headerlink" title="信号灯的概念"></a>信号灯的概念</h6><ul>
<li>一种进程同步机制</li>
</ul>
<p>进程在运行过程中<strong>受信号灯状态控制</strong>, 并能<strong>改变信号灯状态</strong></p>
<ul>
<li>信号灯的状态可以<strong>阻塞</strong>或者<strong>唤醒</strong>进程</li>
<li>信号灯的状态可以被进程改变</li>
</ul>
<h6 id="信号灯的数据结构"><a href="#信号灯的数据结构" class="headerlink" title="信号灯的数据结构"></a>信号灯的数据结构</h6><ul>
<li>定义为一个二元矢量(S,q)</li>
<li>S: 整数,初值非负(S又称信号量,不与信号灯做区分)</li>
<li>q: PCB队列,初值为空集</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SEMAPHORE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> S;	<span class="comment">//整数,初值非负</span></span><br><span class="line">	pointer_PCB q; 	<span class="comment">//队列:进程PCB指针,初值空集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个操作:</p>
<ol>
<li>P操作: 通过(Passeren)</li>
<li>V操作: 释放</li>
</ol>
<ul>
<li>P操作原理</li>
</ul>
<ol>
<li>S减一</li>
<li>如果<strong>差</strong> $\geq$ 0,该进程继续</li>
<li>如果<strong>差</strong> $\leq$ 0.则该进程阻塞,并加入队列q中,转调度函数</li>
</ol>
<ul>
<li>Q操作原理</li>
</ul>
<ol>
<li>S加一</li>
<li>如果<strong>和</strong> $\geq$ 0,该进程继续</li>
<li>如果<strong>和</strong> $\leq$ 0.则该进程<strong>继续</strong>, 同时从q中<strong>唤醒</strong>一个进程</li>
</ol>
<h5 id="P-V操作解决互斥问题"><a href="#P-V操作解决互斥问题" class="headerlink" title="P-V操作解决互斥问题"></a>P-V操作解决互斥问题</h5><ul>
<li>本质: 实现对临界区的互斥访问</li>
<li>应用过程:<ol>
<li>进入临界区之前执行P操作</li>
<li>离开临界区之后再执行V操作</li>
</ol>
</li>
<li>S的初值设置合理(似乎s的初值只能设为1)</li>
</ul>
<h5 id="P-V操作解决同步问题"><a href="#P-V操作解决同步问题" class="headerlink" title="P-V操作解决同步问题"></a>P-V操作解决同步问题</h5><ul>
<li>同步机制实质: 运行条件不满足时,能让进程暂停;条件满足时能让进程继续</li>
<li>基本思路:</li>
</ul>
<ol>
<li>暂停当前进程: 在关键操作<strong>之前</strong>执行<strong>P</strong>操作</li>
<li>继续进程: 在关键操作<strong>之后</strong>执行<strong>V</strong>操作</li>
<li>定义合适的信号量S,表示运行条件</li>
</ol>
<ul>
<li>什么是关键操作:</li>
</ul>
<ol>
<li>是否需要条件</li>
<li>完成与否是否影响另外一个进程</li>
</ol>
<h4 id="Windows和Linux同步机制"><a href="#Windows和Linux同步机制" class="headerlink" title="Windows和Linux同步机制"></a>Windows和Linux同步机制</h4><h5 id="Windows同步机制"><a href="#Windows同步机制" class="headerlink" title="Windows同步机制"></a>Windows同步机制</h5><ul>
<li>临界区</li>
<li>互斥量</li>
<li>信号量</li>
<li>事件</li>
<li>等待</li>
</ul>
<ol>
<li>临界区</li>
</ol>
<ul>
<li>在进程内使用,保证仅一个线程可以申请到该对象</li>
<li>是临界资源的访问<br>等待函数<strong>WaitForXXXObject</strong>: 等待目标对象变成有信号状态就返回.线程结束的时候会变成有信号状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForMultipleObjects</span><br><span class="line">(	</span><br><span class="line">DWORD nCount,		<span class="comment">//等待目标对象数量</span></span><br><span class="line">CONST HANDLE *lpHandles,	<span class="comment">//目标对象的句柄数组</span></span><br><span class="line">BOOL fWaitAll,				<span class="comment">//等待方式</span></span><br><span class="line">DWORD dwMilliseconds);		<span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObjects</span><br><span class="line">(	</span><br><span class="line">HANDLE hHandles,	<span class="comment">//目标对象的句柄</span></span><br><span class="line">DWORD dwMilliseconds);		<span class="comment">//等待时间</span></span><br></pre></td></tr></table></figure>
<ol>
<li>互斥量(Mutex)</li>
</ol>
<ul>
<li>保证只有<strong>一个</strong>线程或者进程可以申请到资源</li>
<li><strong>可以跨进程使用</strong></li>
<li>可以有名称</li>
<li>比临界区耗费更多资源</li>
</ul>
<ol>
<li>信号量(Semaphore)</li>
</ol>
<ul>
<li>允许指定数目的<strong>多个</strong>线程/进程访问临界区</li>
<li>一种资源计数器.用于限制并发线程的数量</li>
<li>初始值可设为n,则表示允许N个进程/线程<strong>并发访问资源</strong>.</li>
<li>可以通过相应函数<strong>增</strong>或者<strong>减</strong>.WaitForSingleObject将信号量减一,ReleaseSemaphore将信号量增一</li>
<li>信号量的值大于0时,有信号状态;小于等于0时,为无信号状态</li>
</ul>
<h5 id="Linux父子进程同步"><a href="#Linux父子进程同步" class="headerlink" title="Linux父子进程同步"></a>Linux父子进程同步</h5><h6 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h6><ul>
<li>进程调用<strong>wait(int status)</strong>阻塞自己,阻塞到有子进程结束.如果没有则一直阻塞.<br>wait收集该子进程信息并彻底销毁</li>
<li>保存进程退出时的状态,如果忽略退出信息,<code>pid = wait(NULL)</code> </li>
</ul>
<h6 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h6><ul>
<li>终结进程,利用status传递进程结束时的状态</li>
<li>变成<strong>僵尸状态</strong>,保留部分PCB信息.给<strong>wait</strong>收集</li>
</ul>
<ol>
<li>正常结束还是异常结束</li>
<li>占用系统CPU总时间</li>
<li>缺页中断次数</li>
</ol>
<ul>
<li>调用schedule,选择新进程运行</li>
</ul>
<h6 id="sleep函数"><a href="#sleep函数" class="headerlink" title="sleep函数"></a>sleep函数</h6><ul>
<li>进程暂停执行nSecond秒</li>
<li>系统暂停调度该进程</li>
<li>相当于Windows的suspend,挂起若干秒</li>
</ul>
<h6 id="父子进程共享普通变量"><a href="#父子进程共享普通变量" class="headerlink" title="父子进程共享普通变量"></a>父子进程共享普通变量</h6><p>对于普通变量,父子进程各自操作变量副本.互不影响</p>
<h6 id="父子进程共享文件资源"><a href="#父子进程共享文件资源" class="headerlink" title="父子进程共享文件资源"></a>父子进程共享文件资源</h6><p>对于文件,父子进程共享同一文件和读写指针</p>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4><h5 id="Windows中的匿名管道通信"><a href="#Windows中的匿名管道通信" class="headerlink" title="Windows中的匿名管道通信"></a>Windows中的匿名管道通信</h5><ul>
<li>管道定义: 进程间的一种通信机制.一个进程A可以通过管道把数据传输给另外一个进程B.前者向管道输入数据,后者向管道输出数据.</li>
<li>工作原理:<br>有读/写两个句柄: <code>CreatePipe(Handle W, Handle R)</code><br>通过写 写句柄向管道中写数据<code>WriteFile(W,Buffer)</code>或者通过输出重定向 向写句柄写入<br>通过读 读句柄,从管道读取数据<code>ReadFile(R,Buffer)</code>.或者通过输入重定向从读句柄读出</li>
<li>仅能用于<strong>父子</strong>或者<strong>兄弟</strong>进程通信</li>
</ul>
<ol>
<li>父进程创建管道<code>CreatePipe(W,R)</code></li>
<li>父进程创建子进程<code>CreateProcess()</code></li>
<li>父进程写或读管道,子进程输入或者输出重定向到管道.</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>相邻的哲学家不可能同时吃饭.<br>用代码表示哲学家的生活就是如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UINT Philosopher(int i)	&#x2F;&#x2F; 线程函数,i是哲学家的编号</span><br><span class="line">&#123;</span><br><span class="line">	while(true)</span><br><span class="line">	&#123;</span><br><span class="line">		思考;</span><br><span class="line">		休息;</span><br><span class="line">		P(S[i]);	&#x2F;&#x2F;取左手边的筷子</span><br><span class="line">		P(S[i+4]%5);&#x2F;&#x2F;取右手边的筷子</span><br><span class="line">		吃饭;</span><br><span class="line">		V(S[i+4]%5);&#x2F;&#x2F;放下右手边的筷子</span><br><span class="line">		V(S[i]);	&#x2F;&#x2F;放下左手边的筷子</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述程序,<strong>吃饭</strong>显然要访问公共资源,是属于临界操作,需要加以适当的P-V操作来限制.筷子是否可用就是<strong>信号量</strong>.</p>
<ul>
<li>死锁的定义: 两个或多个进程无限期的等待永远不会发生的条件的一种系统状态<br>死锁的结果就是每个进程都永远阻塞</li>
</ul>
<h3 id="死锁起因"><a href="#死锁起因" class="headerlink" title="死锁起因"></a>死锁起因</h3><h4 id="系统资源有限"><a href="#系统资源有限" class="headerlink" title="系统资源有限"></a>系统资源有限</h4><p>进程对资源的竞争产生死锁</p>
<h4 id="并发进程推进顺序不当"><a href="#并发进程推进顺序不当" class="headerlink" title="并发进程推进顺序不当"></a>并发进程推进顺序不当</h4><p>进程<strong>请求</strong>或者<strong>释放</strong>资源的顺序不当,也可能导致死锁.<br>例如</p>
<h4 id="关于死锁的一些结论"><a href="#关于死锁的一些结论" class="headerlink" title="关于死锁的一些结论"></a>关于死锁的一些结论</h4><ul>
<li>参与死锁的进程至少是<strong>2</strong>个</li>
<li>参与死锁的进程至少有<strong>2个已经占有资源</strong></li>
<li>参与死锁的所有进程都在等待资源</li>
<li>参与死锁的进程是当前系统中所有进程的子集.<br>死锁会浪费大量的系统资源,甚至导致系统崩溃.</li>
</ul>
<h3 id="预防死锁的策略"><a href="#预防死锁的策略" class="headerlink" title="预防死锁的策略"></a>预防死锁的策略</h3><h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h4><ul>
<li>互斥条件: 资源具有独占性,进程互斥使用资源.</li>
<li>不剥夺条件: 进程在释放资源前(即访问完)不能被其他进程剥夺</li>
<li>部分分配条件: 进程所需要的资源逐步分配.需要时申请和分配.</li>
<li>环路条件: 多个进程构成<strong>环路</strong>,环中每个进程已占用的资源被前一进程申请,自己所需要的新资源又被环中的后裔进程申请</li>
</ul>
<p>上述条件不需要全部满足,满足一个即可</p>
<h4 id="解决死锁的策略"><a href="#解决死锁的策略" class="headerlink" title="解决死锁的策略"></a>解决死锁的策略</h4><ul>
<li>通过设置某些限制条件,破坏死锁四个必要条件中的一个或者多个来防止死锁</li>
</ul>
<ol>
<li>破坏互斥条件: 难</li>
<li>破坏不剥夺条件: 代价大</li>
<li>破坏部分分配条件: 预先静态分配</li>
<li>破坏环路条件: 有序资源分配</li>
</ol>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度概念"><a href="#进程调度概念" class="headerlink" title="进程调度概念"></a>进程调度概念</h3><ul>
<li>在合适的时候以<strong>一定的策略</strong>选择一个<strong>就绪</strong>进程运行.</li>
</ul>
<p>调度时机?调度策略?调度目标?</p>
<h4 id="调度目标"><a href="#调度目标" class="headerlink" title="调度目标"></a>调度目标</h4><ol>
<li>响应速度尽可能快,以更少的时间片进行切换</li>
<li>进程处理时间尽可能短</li>
<li>吞吐量尽可能大</li>
<li>资源利用率尽可能高</li>
<li>对所有进程要公平</li>
<li>避免饥饿</li>
<li>c</li>
</ol>
<p>但是上述部分原则之间存在自相矛盾的现象<br>例如1和2,要求响应速度尽可能快就要占用更多CPU资源,相应地用来处理进程的CPU资源就会减少,进程处理时间就会变长.<br>还有1和3.CPU更频繁切换,调度更频繁进行,和之前一样CPU的有效工作时间就会缩短.因此单位时间可以处理的cpu数量会少.<br>2和5.让一个进程处理时间缩短意味着其他进程获得CPU的概率降低了.是不公平的.<br>对于不同的操作系统满足不同的策略.</p>
<ul>
<li>可以量化的目标</li>
</ul>
<ol>
<li>周转时间: 进程提交给计算机到最终完成所花费的时间.<br>t = t<sub>c</sub> - t<sub>s</sub><br>t<sub>c</sub>是进程完成时间,t<sub>s</sub>是进程开始时间</li>
<li>平均周转时间:<br>t = (t<sub>1</sub> + t<sub>2</sub> + … +t<sub>n</sub>) / n<br>平均周转时间越短说明进程在系统内停留的时间也越短.系统吞吐量也就越大.资源利用率也就越高.</li>
<li>带权周转时间w: 进程在系统中相对停留时间<br>w = t / t<sub>r</sub><br>t: 进程周转时间<br>t<sub>r</sub>进程运行时间</li>
</ol>
<h3 id="典型进程调度算法"><a href="#典型进程调度算法" class="headerlink" title="典型进程调度算法"></a>典型进程调度算法</h3><h4 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS(先来先服务)"></a>FCFS(先来先服务)</h4><p>按照作业进入系统时间先后挑选作业,先进优先被运行.<br>效率不高,只考虑作业等候时间,没考虑<strong>运行时间长短</strong>.不利于短作业</p>
<h4 id="SJF-短作业优先调度算法"><a href="#SJF-短作业优先调度算法" class="headerlink" title="SJF(短作业优先调度算法)"></a>SJF(短作业优先调度算法)</h4><p>参考运行时间,选取运行时间最短的作业投入运行.<br>效率不高,忽视了作业等待时间,容易出现资源饥饿现象.</p>
<h4 id="响应比高者优先调度"><a href="#响应比高者优先调度" class="headerlink" title="响应比高者优先调度"></a>响应比高者优先调度</h4><ul>
<li>作业相应时间与运行时间的比值<br>响应比 = (等待时间 + 运行时间) / 运行时间.计算每个作业的响应比,选择响应比最高的作业优先投入运行.<br>有利于短作业,等候时间长的作业.</li>
</ul>
<h4 id="优先数调度算法"><a href="#优先数调度算法" class="headerlink" title="优先数调度算法"></a>优先数调度算法</h4><p>根据进程优先数,把CPU分配给最高的进程,进程优先数 = 静态优先数+ 动态优先数</p>
<h5 id="静态优先数"><a href="#静态优先数" class="headerlink" title="静态优先数"></a>静态优先数</h5><p>在进程创建时确定,在整个进程运行期间不再更改.</p>
<ul>
<li>进程所需资源多少</li>
<li>程序运行时间长短</li>
<li>进程类型(IO/CPU,前台,后台,核心/用户.</li>
</ul>
<h5 id="动态优先数"><a href="#动态优先数" class="headerlink" title="动态优先数"></a>动态优先数</h5><p>可以改变</p>
<ul>
<li>CPU超过一定时长</li>
<li>当进行I/O操作</li>
<li>当进程等待超过一定时长.</li>
</ul>
<h4 id="循环轮转调度法"><a href="#循环轮转调度法" class="headerlink" title="循环轮转调度法"></a>循环轮转调度法</h4><p>把所有进程按先进先出的原则排成队列.新来进程加到队列末尾.<br>进程以时间片q为单位轮流使用CPU,,刚运行完一个时间片的进程排到队列末尾,等候下一轮运行.逻辑上是环形.</p>
<ul>
<li>优点: 平等机会获得CPU,等待固定时间就可以重新获得CPU<br>时间片:<br>如果q太大: 交互性差,甚至退化成FCFS算法<br>如果q的值太小: 进程切换频繁,系统开销增加<br>改进: 让时间片大小可变,组织多个就绪队列.</li>
</ul>
<h3 id="Linux进程调度"><a href="#Linux进程调度" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h3><p>Linux进程类型: </p>
<ol>
<li><p>普通进程<br>采用动态优先级调度,调度程序<strong>周期性</strong>的修改优先级(避免饥饿)<br>只要进程占用CPU,优先级就随时间流失而不断下降.task_struct的counter表示优先级.系统调用<strong>sched_setscheduler()</strong>可以改变调度策略.实时进程子孙进程也是实时进程.</p>
</li>
<li><p>实时进程<br>采用静态优先级调度,由用户<strong>预先指定</strong>,以后不会改变<br>实时进程调度策略为FIFO或者RR(时间片轮转).当采用FIFO策略时,当前实时进程会一直占用CPU直到被<strong>阻塞</strong>或者<strong>被抢占</strong>或者<strong>退出</strong>.阻塞后再就绪时被添加到同优先级队列的末尾.当采用RR策略时,与其他实时进程共同使用CPU,确保同优先级的多个进程能共享CPU.</p>
</li>
</ol>
<h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><ul>
<li><p>中断处理过程中直接调用schedule().<br>时钟中断,I/O中断,系统调用和异常.<br>内核被动调度情形.</p>
</li>
<li><p>中断处理过程返回用户态时直接调用schedule()<br>必须根据need_resched标记来确定是否调用</p>
</li>
<li>内核线程可以直接调用schedule()<br>属于内核主动调度的情形</li>
<li>用户态进程<strong>只能陷入内核后</strong>在中断处理过程中被动调用<br>同样也是必须根据need_resched标记.</li>
</ul>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><ul>
<li>内核挂起当前CPU上的进程并恢复之前挂起的某个进程,任务切换,上下文切换</li>
<li>与中断上下文切换有差别<br>中断前后在同一进程上下文中,只是<strong>用户态</strong>转向<strong>内核态</strong>执行.</li>
<li>进程上下文包含了进程执行需要的所有信息.</li>
</ul>
<ol>
<li>用户地址空间:程序代码,数据,用户堆栈</li>
<li>控制信息: 进程描述符,内核堆栈</li>
<li>硬件上下文</li>
</ol>
<ul>
<li>schedule()函数<br>选择新进程<code>next = pick_next_task(rq,prerv)</code>,进程调度算法<br>调用宏<code>context_switch(rq,prev,next)</code>切换进程上下文,在宏当中实际上是调用<code>switch_to(prev,next)</code>来切换上下文的.</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理功能"><a href="#内存管理功能" class="headerlink" title="内存管理功能"></a>内存管理功能</h3><p>存储器功能需求: 容量足够大,速度足够快,信息永久保存,多道程序运行.</p>
<ul>
<li>共享: 代码和数据共享,节省内存</li>
<li>保护: 不允许程序之间非法的相互访问.</li>
</ul>
<p>存储管理的功能: </p>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><p>把程序中的地址(虚拟/虚/逻辑)变换成内存中的真实地址的过程,方式有三种,固定地址映射,静态地址映射,动态地址映射.</p>
<h5 id="固定地址映射"><a href="#固定地址映射" class="headerlink" title="固定地址映射"></a>固定地址映射</h5><p>在编程或者编译时确定逻辑地址和物理地址的映射关系,但是在程序加载的时候必须放在<strong>指定的内存区域</strong>,但是容易产生地址冲突,运行失败.</p>
<h5 id="静态地址映射"><a href="#静态地址映射" class="headerlink" title="静态地址映射"></a>静态地址映射</h5><p>程序<strong>装入</strong>时由OS完成逻辑地址到物理地址的映射.设<strong>逻辑地址</strong>为VA,<strong>装入基址</strong>为BA,<strong>物理地址</strong>为MA.有</p>
<script type="math/tex; mode=display">
MA = BA + VA</script><ul>
<li>程序运行之前确定映射关系</li>
<li>程序装入之后不能移动,移动之后必须放回原来的位置</li>
<li>程序占用连续的内存空间.</li>
</ul>
<h5 id="动态地址映射"><a href="#动态地址映射" class="headerlink" title="动态地址映射."></a>动态地址映射.</h5><p>在程序<strong>执行过程中</strong>把逻辑地址转换为物理地址.例如,<code>MOV AX,[500]</code>OS就会在访问500单元时执行地址转换.如果程序在过程中有移动,则可能产生新的BA,相应的MA也就需要重新计算.</p>
<ul>
<li>程序占用的内存空间可以动态变化,BA需要及时更新.</li>
<li>不要求占用连续的内存空间,每段程序的BA应该知道</li>
<li>便于多个进程共享代码</li>
<li>需要硬件支持MMU(内存管理)</li>
</ul>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>解决问题: 程序过多或者过大时,内存不够,不能运行.多个程序并发时地址冲突,不能运行.</p>
<ul>
<li>面向用户的虚拟封闭内存.</li>
</ul>
<ol>
<li>线行地址空间</li>
<li>容量4G</li>
<li>封闭空间</li>
<li>和物理地址分离(地址无冲突)</li>
<li>程序员编程时使用线行虚拟地址</li>
</ol>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>解决目标: 为程序运行分配足够的内存空间.<br>需要解决的问题:</p>
<ol>
<li>放置策略: 程序调入内存时将其放置在哪个内存区?</li>
<li>调入策略: 何时把要运行的代码和要访问的数据存入内存</li>
<li>淘汰策略: 内存空间不够时,迁出哪些代码或数据以腾出内存</li>
</ol>
<h4 id="存储保护"><a href="#存储保护" class="headerlink" title="存储保护"></a>存储保护</h4><p>解决目标: 保证在内存中的多道程序只在给定的存储区域中活动且互不干扰.防止访问越权和越界<br>使用<strong>界址寄存器</strong>来限制,程序访问内存时硬件自动将目的地址与下限寄存器和上限寄存器中存放的地址界限进行比较,判断是否越界.</p>
<h3 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h3><h4 id="分区内存管理"><a href="#分区内存管理" class="headerlink" title="分区内存管理"></a>分区内存管理</h4><p>根据分区管理形式不同可以分为</p>
<ul>
<li>单一区存储管理</li>
<li>分区存储管理,其中还可细分为固定分区和动态分区.</li>
</ul>
<h5 id="单一区存储管理"><a href="#单一区存储管理" class="headerlink" title="单一区存储管理"></a>单一区存储管理</h5><p>用户区不分区,完全被一个程序占用</p>
<ul>
<li>优点: 简单,不需要复杂的硬件支持,适于单用户单任务OS</li>
<li>缺点: 程序运行占用整个内存,即使程序很小也是这样,内存浪费,利用率低</li>
</ul>
<h5 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h5><p>把用户区内存划分为若干大小不等的分区,供不同的程序使用,根据分区的<strong>时机</strong>分为固定分区和动态分区</p>
<h6 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h6><p>把内存<strong>固定</strong>地划分为若干个大小不等的分区供程序使用,每个分区的<strong>位置</strong>和<strong>大小</strong>都固定.系统运行期间不再改变.用<strong>分区表</strong>记录分区的位置大小和使用情况.</p>
<ul>
<li>在程序装入前,内存已被分区,不再改变</li>
<li>每个分区大小不相同,适应大小不同的程序</li>
<li>系统要维护分区表</li>
</ul>
<p>缺点: 浪费内存,大程序可能无法运行.</p>
<h6 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h6><p>在程序装入的时候创建分区,使分区的大小刚好和程序的大小相适应.存在内存碎片.</p>
<h6 id="空闲区表如何排序"><a href="#空闲区表如何排序" class="headerlink" title="空闲区表如何排序"></a>空闲区表如何排序</h6><ul>
<li>放置策略(空闲区表排序原则)<ol>
<li>按空闲区位置(首址)递增排序.(首次适应法)</li>
<li>按空闲区位置(首址)递减排序</li>
<li>按空闲区大小的递增排序.</li>
<li>按空闲区大小的递减排序</li>
</ol>
</li>
</ul>
<h6 id="首次适应法"><a href="#首次适应法" class="headerlink" title="# 首次适应法"></a># 首次适应法</h6><p>尽可能先使用<strong>低地址</strong>的内存,当需要较大分区时在高地址空间有较大的满足概率.</p>
<h6 id="最佳适应法"><a href="#最佳适应法" class="headerlink" title="# 最佳适应法"></a># 最佳适应法</h6><p>尽可能使用<strong>较小</strong>的空闲区,保留大的空闲区,当需要较大分区时有较大满足可能性</p>
<h6 id="最坏适应法"><a href="#最坏适应法" class="headerlink" title="# 最坏适应法"></a># 最坏适应法</h6><p>节省遍历时间.最大的分区切割以后还是一个较大的分区,还可能可以让程序运行.</p>
<h5 id="分区的回收"><a href="#分区的回收" class="headerlink" title="分区的回收"></a>分区的回收</h5><p>回收程序释放的分区,登记到<strong>空闲区表</strong>中,以便再次分区.</p>
<ul>
<li>考虑释放区与现有空闲区<strong>是否相邻</strong></li>
<li>如不相邻则直接插入空闲区表</li>
<li>如果相邻则与<strong>空闲区合并</strong>后更新空闲区表.</li>
</ul>
<h4 id="内存覆盖技术"><a href="#内存覆盖技术" class="headerlink" title="内存覆盖技术"></a>内存覆盖技术</h4><ul>
<li>在较小内存空间中运行较大程序<h5 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h5></li>
<li>常驻区: 被某段单独且固定地占用,可以划分多个.</li>
<li>覆盖区: 能被多段共用,可划分多个.</li>
</ul>
<h5 id="覆盖的缺点"><a href="#覆盖的缺点" class="headerlink" title="覆盖的缺点"></a>覆盖的缺点</h5><ul>
<li>编程复杂,程序员划分程序模块并确定覆盖关系.</li>
<li>程序执行时间长,从外存装入内存耗时.</li>
</ul>
<h4 id="内存交换技术"><a href="#内存交换技术" class="headerlink" title="内存交换技术"></a>内存交换技术</h4><p>在<strong>小内存</strong>中,<strong>并发</strong>的运行多个进程.</p>
<ul>
<li>原理: 在内存不够时将进程<strong>写入到磁盘</strong>,当进程要运行时重新写回内存.<h5 id="交换技术的缺点"><a href="#交换技术的缺点" class="headerlink" title="交换技术的缺点"></a>交换技术的缺点</h5></li>
<li><strong>换入</strong>和<strong>换出</strong>增加CPU开销.</li>
<li>交换单位太大<h5 id="需要考虑的问题"><a href="#需要考虑的问题" class="headerlink" title="需要考虑的问题"></a>需要考虑的问题</h5></li>
<li>减少交换传送的信息量</li>
<li>外存交换空间的管理办法</li>
<li>程序换入时的地址重定位.</li>
</ul>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><ul>
<li>过小的空闲区,难以实际利用.降低内存有效利用率.</li>
</ul>
<p><strong>最佳适应法</strong>最容易产生内存碎片.</p>
<h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><ul>
<li>规定门限值,如果剩余部分少于门限值,则空闲区不进行分割,全部分配给用户.</li>
</ul>
<h5 id="方法二-碎片拼接"><a href="#方法二-碎片拼接" class="headerlink" title="方法二: 碎片拼接"></a>方法二: 碎片拼接</h5><ul>
<li>将所有空闲区集中一起构成一个大的空闲区</li>
<li>拼接的时机: </li>
</ul>
<ol>
<li>释放区回收的时候(拼接频率过大,系统开销大)</li>
<li>系统找不到足够大的空闲区的时候(空闲区的管理复杂)</li>
<li>定期(空闲区的管理复杂)</li>
</ol>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>消耗系统资源</li>
<li>离线拼接,需要对所有作业进行离线,暂停作业进行拼接</li>
<li>重新定义拼接,每个作业内存的大小,位置发生了变化,需要重新定义.</li>
</ul>
<h5 id="方法三-解除程序占用连续内存才能运行的限制"><a href="#方法三-解除程序占用连续内存才能运行的限制" class="headerlink" title="方法三: 解除程序占用连续内存才能运行的限制"></a>方法三: 解除程序占用连续内存才能运行的限制</h5><ul>
<li>把程序<strong>分拆多个部分装入不同分区</strong>,充分利用碎片.</li>
</ul>
<h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><ul>
<li>使得大的程序能在较小内存中运行</li>
<li>多个程序可以在小内存中运行</li>
<li>多个程序<strong>并发运行</strong>地址不冲突.</li>
<li>无碎片</li>
<li><p>实现思路: 只把当前必要的很小一部分代码和数据装入内存,其余代码和数据需要的时候再装入,不再运行的代码和数据从内存中删除.</p>
</li>
<li><p>程序运行的局部性: 在一个<strong>有限的</strong>时间段内访问的代码和数据往往集中在<strong>有限的地址范围内</strong>.</p>
</li>
<li>把程序的一部分装入内存在较大概率上也足够让其运行一小段时间.<h4 id="页式虚拟存储管理"><a href="#页式虚拟存储管理" class="headerlink" title="页式虚拟存储管理"></a>页式虚拟存储管理</h4></li>
<li>把进程和内存都按一定大小(如1k,2K,4K等)划分成等大小的小片,进程的小片叫<strong>页</strong>,内存的小片叫<strong>页框</strong>,</li>
</ul>
<p>只把程序<strong>部分页</strong>装入内存即可运行.页在内存中占用的页框<strong>不必相邻</strong>.需要新页时,按需从硬盘调入内存.</p>
<h4 id="页表和页式地址映射"><a href="#页表和页式地址映射" class="headerlink" title="页表和页式地址映射"></a>页表和页式地址映射</h4><p>虚拟地址(VA)可以被分解成<strong>页号P</strong>和<strong>页内偏移W</strong></p>
<ul>
<li>页号 = VA / 页的大小</li>
<li>页内偏移 = VA % 页的大小</li>
<li>计算页号和页内偏移的另一种方法: </li>
</ul>
<ol>
<li>页号P = VA &gt;&gt; n, 其中n为页的大小2<sup>n</sup></li>
<li>页内偏移W = VA &amp;&amp;(2<sup>n</sup>-1)</li>
</ol>
<ul>
<li>页面映射表: 记录页与页框之间的对应关系.<h5 id="页式地址映射"><a href="#页式地址映射" class="headerlink" title="页式地址映射"></a>页式地址映射</h5>将虚拟地址(页式地址)映射到物理地址上.</li>
</ul>
<ol>
<li>从VA中分离P和W</li>
<li>查页表,以P为索引查页框号P’</li>
<li>计算物理地址MA = P’ $\times$ 页面大小 + W</li>
</ol>
<h4 id="快表技术和页面共享技术"><a href="#快表技术和页面共享技术" class="headerlink" title="快表技术和页面共享技术"></a>快表技术和页面共享技术</h4><ul>
<li>快表(Cache): 页表放在<strong>Cache</strong>中. 容量小,访问快,成本高,慢表部分内容复制,地址映射时优先访问快表.</li>
<li>慢表: 页表放在内存中<br>如果在快表中找到了所需的数据,叫<strong>命中</strong>.没有命中访问慢表,同时更新快表.合理页面调度策略能够快表具有较高命中率</li>
</ul>
<h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p>页表扩充: 带<strong>中断位</strong>的页表.</p>
<ul>
<li>定义: 访问的目的页<strong>不在内存</strong>,系统产生异常中断.</li>
<li>缺页中断处理程序: 把所缺的页从页表指出的辅存地址调入内存中的某个页框中,并更新页表中对应的中断位为<strong>0</strong>.</li>
<li>缺页率: 缺页次数 / 访问次数</li>
</ul>
<h4 id="页面淘汰"><a href="#页面淘汰" class="headerlink" title="页面淘汰"></a>页面淘汰</h4><ul>
<li>选择淘汰<strong>哪一页</strong>的规则.</li>
<li>页面抖动: 页面在<strong>内存</strong>和<strong>辅存</strong>间频繁交换的现象,降低系统效率.</li>
</ul>
<p>一个好的淘汰策略应该具有较低的缺页率,页面抖动较少.</p>
<ul>
<li>常用淘汰算法</li>
</ul>
<ol>
<li>最佳算法(OPT): 淘汰以后<strong>不再需要</strong>或者<strong>最远的将来</strong>才会用到的页面.0</li>
</ol>
<p>理论上最佳,但实践中该算法<strong>无法实现</strong>,在进程访问完之前并不知道将来需要访问什么页面</p>
<ol>
<li>先进先出算法(FIFO): 淘汰在内存中<strong>停留时间最长</strong>的页面</li>
</ol>
<p>实现简单: 只有按顺序地址空间访问时才有较高命中率.</p>
<ol>
<li>最久未使用淘汰算法: 淘汰最长时间未被使用的页面(LRU)</li>
</ol>
<p>页面设置一个<strong>移位寄存器R</strong>,每当页面被访问则将其重置1. 周期性地将所有页面的R左移一位. 当需要淘汰页面时,选择R值最大的页(R值越大,对应页的未被使用时间也就越长.R的位数越多,位移周期越小就越精确.但硬件成本也就越高.</p>
<ol>
<li>最不经常用算法(LFU)</li>
</ol>
<p>选择到当前时间为止访问次数最少的页面.</p>
<h3 id="段式和段页式虚拟内存"><a href="#段式和段页式虚拟内存" class="headerlink" title="段式和段页式虚拟内存"></a>段式和段页式虚拟内存</h3><p>把进程<strong>按逻辑意义</strong>分成多个段,每个段有<strong>段名</strong>,长度不定.有点像汇编里面的code segment stack segment</p>
<ul>
<li>以段为单位装入,每段分配连续的内存.段与段之间不需要相邻</li>
</ul>
<h4 id="段式地址映射机制"><a href="#段式地址映射机制" class="headerlink" title="段式地址映射机制"></a>段式地址映射机制</h4><p>段表: 记录每段在内存中的映射地址,包括<strong>段号</strong>,<strong>段长</strong>,<strong>基地址</strong>.</p>
<ul>
<li>段号: 段的编号(<strong>唯一</strong>)</li>
<li>段长: 该段的长度</li>
<li>基地址: 在内存中的首地址</li>
</ul>
<p>映射过程: </p>
<ol>
<li>由逻辑地址VA分离出(S,W)</li>
<li>查询段表</li>
<li>物理地址MA = B + W</li>
</ol>
<ul>
<li>段的共享: </li>
</ul>
<ol>
<li>在内存中只有一份存储</li>
<li>共享段被多个进程映射到各自段表</li>
<li>需要共享的模块可以设置为单独的段.</li>
</ol>
<ul>
<li>缺点:</li>
</ul>
<ol>
<li>需要连续空间</li>
<li>最大尺寸受到内存大小限制</li>
</ol>
<h4 id="段式-VS-页式"><a href="#段式-VS-页式" class="headerlink" title="段式 VS 页式"></a>段式 VS 页式</h4><p>页式系统是一位地址空间,段式是二维.</p>
<h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><p>地址构成: 段号,页号,页内偏移.</p>
<h5 id="段页式地址的映射机构"><a href="#段页式地址的映射机构" class="headerlink" title="段页式地址的映射机构"></a>段页式地址的映射机构</h5><ul>
<li>同时采用<strong>段表</strong>和<strong>页表</strong>实现地址映射</li>
<li>系统为<strong>每一个进程</strong>建立一个<strong>段表</strong></li>
<li>系统为<strong>每一个段</strong>建立一个<strong>页表</strong></li>
<li>段表给出每段的<strong>页表基址</strong>和<strong>页表长度</strong></li>
<li>页表给出每页对应的页框.</li>
</ul>
<h3 id="Intel-CPU和-Linux内存管理"><a href="#Intel-CPU和-Linux内存管理" class="headerlink" title="Intel CPU和 Linux内存管理"></a>Intel CPU和 Linux内存管理</h3><h4 id="Intel-CPU物理结构"><a href="#Intel-CPU物理结构" class="headerlink" title="Intel CPU物理结构"></a>Intel CPU物理结构</h4><h5 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h5><ul>
<li>20位寻址能力</li>
<li>地址表示方式:段地址(16位) : 偏移地址(16位)</li>
<li>段地址4位对齐</li>
<li>程序直接存储物理地址</li>
</ul>
<h5 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h5><ul>
<li>32位地址: 4G内存</li>
<li>支持多任务,任务切换,上下文保护</li>
<li>进程隔离</li>
<li>支持<strong>分段机制</strong>和<strong>分页机制</strong></li>
</ul>
<p>每个进程的运行结果只会影响自身.</p>
<ul>
<li>控制寄存器CR0<br>PE: 0 - 实模式 ; 1 - 保护模式<br>PG: 允许分页<br>PE和PG分别在寄存器的两头.</li>
<li>控制寄存器CR2:<br>如果发生缺页,引发缺页的线性地址保存在CR2中</li>
<li>控制寄存器CR3:<br>页目录基址(高20位)</li>
</ul>
<h5 id="x86-CPU架构下三种地址"><a href="#x86-CPU架构下三种地址" class="headerlink" title="x86 CPU架构下三种地址"></a>x86 CPU架构下三种地址</h5><ul>
<li>逻辑地址(就是汇编里面最常用的那种地址</li>
<li>线性地址: 由<strong>逻辑地址</strong>转换得到</li>
<li>物理地址: 如果<strong>未分页</strong>则线性地址就是物理地址.如果分页那么线性地址不等于物理地址.</li>
</ul>
<h4 id="Intel-CPU段机制"><a href="#Intel-CPU段机制" class="headerlink" title="Intel CPU段机制"></a>Intel CPU段机制</h4><ul>
<li>一段<strong>连续内存</strong></li>
</ul>
<h5 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h5><ul>
<li>段基址: 32位(段基址1 + 段基址2)</li>
<li>段界限: 20位(段界限1 + 段界限2)</li>
<li>把逻辑地址转换到线性地址.</li>
</ul>
<p>描述段的属性.8字节:</p>
<ul>
<li>段基址</li>
<li>段界限</li>
<li>段属性</li>
<li>段类型</li>
<li>访问该段所需要的最小特权级</li>
<li>是否在内存.<h5 id="描述符表"><a href="#描述符表" class="headerlink" title="描述符表"></a>描述符表</h5></li>
<li>存放描述符的数组,长度为8字节的整数倍</li>
</ul>
<ol>
<li>全局描述符表(GDT),包含所有进程可用的段的描述符,系统仅一个</li>
<li>局部描述符表(LDT),包含与特定进程相关的描述符,一个进程一个</li>
<li>中断描述符表(IDT),包含中断服务程序的描述符.</li>
</ol>
<h5 id="选择子-Selecto"><a href="#选择子-Selecto" class="headerlink" title="选择子(Selecto)"></a>选择子(Selecto)</h5><ul>
<li>用于选择GDT/LDT中的某个描述符,存放在<strong>段寄存器</strong>中,高13位是整数索引.</li>
<li>构成: </li>
</ul>
<ol>
<li>索引域: 给出段描述符在GDT或者LDT中的位置</li>
<li>TI域,GDT(0)或者LDT(T)</li>
<li>特权级别域,两位.</li>
</ol>
<h4 id="硬件分页"><a href="#硬件分页" class="headerlink" title="硬件分页"></a>硬件分页</h4><ul>
<li>大小: 4KB</li>
<li>通过设置CR0的PG位开启分页功能.</li>
</ul>
<h5 id="普通页表实现问题"><a href="#普通页表实现问题" class="headerlink" title="普通页表实现问题:"></a>普通页表实现问题:</h5><p>32位OS(4G空间),</p>
<ul>
<li>每页<strong>4K</strong>,</li>
<li>页表每个记录占<strong>4个字节</strong>.</li>
<li>进程页数 = 4G / 4K = <strong>1M</strong> 个页</li>
<li><strong>页表记录</strong>应该有<strong>1M</strong>条记录</li>
<li>页表所占内存: 1M $\times$ 4字节 = 4M</li>
<li>页表所占<strong>页框</strong>数 = 4M / 4K = 1K 页框</li>
</ul>
<p>问题: 难以找到<strong>连续1K个页框</strong>,页表全部装入<strong>过度消耗</strong>.<br>解决: 存储到离散页框.存部分. </p>
<ul>
<li>访问数组需要<strong>三次</strong>访问内存</li>
<li>页目录调入内存</li>
<li>页表按需要调入内存.<br>Linux实际上是二级页表,采用三级页表机制,增加对硬件的适应性.</li>
</ul>
<h4 id="Linux对段的支持"><a href="#Linux对段的支持" class="headerlink" title="Linux对段的支持."></a>Linux对段的支持.</h4><ul>
<li>进程建立,段机制对寄存器的初始化: start_thread().</li>
<li>Linux四个范围一样的段: 0 ~ 0xFFFFFFFF(4G)</li>
<li>内核特权级为0,用户特权级为3</li>
<li>利用段机制隔离用户数据和系统数据</li>
<li>避免/简化虚拟地址到线性地址的转换.</li>
</ul>
<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h3 id="设备管理概念"><a href="#设备管理概念" class="headerlink" title="设备管理概念"></a>设备管理概念</h3><ol>
<li>按交互对象</li>
<li>按交互方向</li>
<li>按外设特性</li>
</ol>
<p>设备管理的主要功能: </p>
<ul>
<li>设备分配: 按照一定策略,为申请设备的进程分配设备,记录设备的使用情况.(<strong>基本任务</strong>)</li>
<li>设备映射: 设备管理模块将逻辑设备映射到物理设备的功能.</li>
<li>设备独立性: 物理设备对用户透明,用户使用统一规范的方式使用设备.用户编程的时候使用设备逻辑名,由系统实现逻辑设备到物理设备的转换.</li>
<li>设备驱动: 对物理设备进行控制实现I/O操作.</li>
<li>设备驱动与硬件密切相关,每类设备配置特定的驱动程序,驱动程序一般由设备厂商根据OS来编写.OS仅对设备驱动的接口提出要求.</li>
</ul>
<h3 id="Spooling系统"><a href="#Spooling系统" class="headerlink" title="Spooling系统"></a>Spooling系统</h3><p>独占性设备包括<strong>所有的字符型设备</strong><br>共享性设备包括<strong>所有块型设备</strong></p>
<h4 id="独占性设备的分配"><a href="#独占性设备的分配" class="headerlink" title="独占性设备的分配"></a>独占性设备的分配</h4><ol>
<li>申请</li>
<li>分配</li>
<li>发送使用指令</li>
<li>完成I/O传输</li>
<li>释放设备</li>
<li>回收设备</li>
</ol>
<p>在进程申请成功直到释放用完之前独占设备.</p>
<h4 id="共享型设备"><a href="#共享型设备" class="headerlink" title="共享型设备"></a>共享型设备</h4><p><strong>不需要申请</strong>,不存在占用或者释放设备的问题.但是I/O期间只能有一个进程使用设备. </p>
<h4 id="虚拟技术"><a href="#虚拟技术" class="headerlink" title="虚拟技术"></a>虚拟技术</h4><ul>
<li>在一类物理设备模拟另一类物理设备的技术</li>
<li>借助<strong>辅存部分区域</strong>模拟独占设备.将独占转换为共享设备</li>
<li>虚拟设备: 用来模拟独占设备的区域. </li>
<li>虚拟分配: 当进程需要与独占设备交换信息时,就采用虚拟技术将与该独占设备所对应的虚拟设备分配给他</li>
</ul>
<h5 id="SPOOL系统原理"><a href="#SPOOL系统原理" class="headerlink" title="SPOOL系统原理"></a>SPOOL系统原理</h5><p>任务执行前: 预先将程序和数据输入到输入井中</p>
<p>任务运行时: 使用数据,从输入井中取出</p>
<p>任务运行时: 输出数据时,把数据写入到输出井</p>
<p>任务运行完: 外设空闲时输出全部数据和信息</p>
<h3 id="Linux模块机制"><a href="#Linux模块机制" class="headerlink" title="Linux模块机制"></a>Linux模块机制</h3><ul>
<li><p>LKM: 解决单体内核机制的不足</p>
</li>
<li><p>一种<strong>未经链接</strong>的可执行代码</p>
</li>
<li>经过装载(即<strong>链接</strong>)成为内核的一部分</li>
<li>可以动态加载或者卸载. </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译模块</span></span><br><span class="line">gcc -o _D_KERNEL_ -DMOUDLE hello.c <span class="comment">#两个参数提示GCC把hello.c编译为模块</span></span><br><span class="line"><span class="comment">#安装模块</span></span><br><span class="line">sudo insmod hellomodule.ko <span class="comment">#发现调用hello_init函数</span></span><br><span class="line"><span class="comment">#删除模块</span></span><br><span class="line">sudo rmmod module <span class="comment">#卸载模块调用hello_exit函数</span></span><br><span class="line"><span class="comment">#查看内核信息,输出函数不是printf是printk,所以在内核信息中查看</span></span><br><span class="line">dmesg</span><br><span class="line"><span class="comment"># 查看模块</span></span><br><span class="line">lsmod </span><br><span class="line"><span class="comment">#注册模块</span></span><br><span class="line">module_init(hello_init)</span><br><span class="line"><span class="comment">#卸载模块</span></span><br><span class="line">module_exit(hello_exit)</span><br></pre></td></tr></table></figure>
<h4 id="带参数的模块"><a href="#带参数的模块" class="headerlink" title="带参数的模块"></a>带参数的模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module_param(name, <span class="built_in">type</span>,perm);</span><br><span class="line"><span class="comment"># name: 模块参数的名称</span></span><br><span class="line"><span class="comment"># type: 模块参数的数据类型,int,bool等</span></span><br><span class="line"><span class="comment"># perm: 模块参数的权限</span></span><br></pre></td></tr></table></figure>
<h3 id="Linux驱动程序-LDD"><a href="#Linux驱动程序-LDD" class="headerlink" title="Linux驱动程序(LDD)"></a>Linux驱动程序(LDD)</h3><ul>
<li>应用程序通过<strong>驱动程序</strong>间接访问设备</li>
<li>驱动程序工作在核态.<h4 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h4></li>
<li>字符设备:以字节为单位逐个进行I/O操作.</li>
<li>块设备: 存取通过buffer,cache来进行.例如硬盘.</li>
<li>网络设备.</li>
<li><p>设备文件: 硬件设备作为<strong>文件</strong>看待</p>
</li>
<li><p>主设备号</p>
</li>
</ul>
<ol>
<li>标识该设备种类,标识驱动程序</li>
<li>主设备号范围: 0~255</li>
<li>Linux内核支持动态分配主设备号</li>
</ol>
<ul>
<li>次设备号</li>
</ul>
<ol>
<li>同一设备驱动程序的不同硬件设备</li>
<li>只在<strong>驱动程序内部</strong>使用.</li>
</ol>
<p>驱动程序的<strong>注册</strong>和<strong>注销</strong>一定要实现.</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows固定采用<strong>DriverEntry</strong>作为入口函数<br>给<strong>pDriverObject-&gt;DriverUnload</strong>赋值退出函数指针.</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>用户通过<strong>读写指针</strong>来读取信息项.</p>
<h4 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h4><ol>
<li>文件用途</li>
<li>文件操作权限</li>
<li>文件性质</li>
</ol>
<h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><p>指定文件类型,操作特性,存取保护等<strong>一组信息</strong>.放在文件所在目录的目录文件中.<br>在MS-DOS系统中,文件属性占目录项的<strong>一个字节</strong><br>00000001-只读属性<br>00000010-隐藏属性.</p>
<h4 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h4><ul>
<li>负责管理文件的机构</li>
</ul>
<h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><ul>
<li>记录式文件: 记录结构化的数据</li>
<li>流式文件: 信息项是<strong>字节</strong>,节省存储空间</li>
</ul>
<p>现代操作系统中文件都是流式文件.由应用程序去解释这些文件.</p>
<h4 id="文件存取方法"><a href="#文件存取方法" class="headerlink" title="文件存取方法"></a>文件存取方法</h4><h5 id="顺序存取"><a href="#顺序存取" class="headerlink" title="顺序存取"></a>顺序存取</h5><p>按照文件信息项排列顺序依次存取.</p>
<ul>
<li>读写指针: 文件打开时,读写指针直向第一个信息项,每存取一个信息项,读写指针自动加一而指向下一个信息项.<h5 id="随机存取"><a href="#随机存取" class="headerlink" title="随机存取"></a>随机存取</h5></li>
<li>直接存取,存取操作时<strong>指定存取的位置</strong></li>
<li>对流式文件或者记录为<strong>定长</strong>的文件容易确定存取位置.<h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3></li>
<li>文件在存储设备上的存储方式</li>
</ul>
<h4 id="连续文件"><a href="#连续文件" class="headerlink" title="连续文件"></a>连续文件</h4><ul>
<li>按<strong>逻辑块</strong>的顺序存放在硬盘连续的物理存储块中</li>
<li>文件目录记录文件长度(块数)和第一个存储块的块号</li>
</ul>
<p>缺点: 不容易动态增长,不利于文件的插入和删除.需要预留空间</p>
<h4 id="串联文件"><a href="#串联文件" class="headerlink" title="串联文件"></a>串联文件</h4><ul>
<li>文件存放<strong>不连续的</strong>的存储块中,每个存储块有一个指针(next),指向下一个存储块.</li>
<li>文件目录记录文件指明文件名和第一个存储块的块号</li>
</ul>
<p>缺点: 存取速度慢,不适合随机存取,next指针占用内存,适用于FAT系统.</p>
<h3 id="FAT文件系统"><a href="#FAT文件系统" class="headerlink" title="FAT文件系统"></a>FAT文件系统</h3><ul>
<li>串联文件应用.</li>
<li>FAT将next有序集中放到FAT表中.<h4 id="文件访问过程"><a href="#文件访问过程" class="headerlink" title="文件访问过程:"></a>文件访问过程:</h4></li>
</ul>
<ol>
<li>访问文件目录: 找0块的块号i</li>
<li>访问FAT找下一块的块号: <code>FAT(i)</code>.i是当前的块号.<br>文件分配表的缺点: </li>
<li>读文件时,先读FAT,<strong>影响使用效率</strong>.</li>
<li>FAT占用存储空间.存储块越多,FAT元素越多.且元素位宽越长,占用更多额外的存储空间.</li>
</ol>
<p>如果存储块有$2^N$块,FAT有$2^N$个元素,每项只需要需要N位的宽度</p>
<h4 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h4><ul>
<li>磁盘上最小可寻址存储单元(512字节)<h4 id="簇-存储块"><a href="#簇-存储块" class="headerlink" title="簇 = 存储块"></a>簇 = 存储块</h4></li>
<li>设备最小的存储单元,固定数量的扇区.<br>360K磁盘 簇 = 2个扇区(1024字节)<br>10MB硬盘 簇 = 8个扇区(4096字节)<br>2GB硬盘: 簇 = 64个扇区(32KB)<br>FAT元素数目和簇的数目一样多.<br>磁盘容量 = FAT长度 $\times$ 簇容量 = FAT长度 $\times$ 簇扇区数 $\times$ 512 字节.</li>
</ul>
<h3 id="文件存储和目录"><a href="#文件存储和目录" class="headerlink" title="文件存储和目录"></a>文件存储和目录</h3><p>记录磁盘空闲块的方法</p>
<h4 id="空闲文件目录"><a href="#空闲文件目录" class="headerlink" title="空闲文件目录"></a>空闲文件目录</h4><ul>
<li>把连续空闲区看成一个特殊文件,由多个空闲块构成<br>为空闲文件建立专门的目录: <strong>空闲文件目录</strong>,每个表项对应一个空闲文件.包括第一个空闲块号,空闲块个数.<h4 id="空闲块链"><a href="#空闲块链" class="headerlink" title="空闲块链"></a>空闲块链</h4></li>
<li>把所有空闲块链接在一起</li>
<li>当申请者需要空闲块时, 链头开始搜索所需要的空闲块</li>
<li>当需要回收空闲块时,把释放的空闲块<strong>逐个</strong>加在链尾</li>
</ul>
<h4 id="位视图"><a href="#位视图" class="headerlink" title="位视图"></a>位视图</h4><p>从内存怒中划出若干个字节, 每个bit表示要给存储块空闲或者被占用.</p>
<h4 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h4><ul>
<li>文件名址录: 记录文件名和存放地址的目录表.</li>
<li>具有将文件名转换为外存物理地址的功能</li>
<li><strong>文件属性</strong>也记录在目录里面</li>
</ul>
<p>文件目录以文件形式存于外村,这个文件叫目录文件..</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Notes/" rel="tag"><i class="fa fa-tag"></i> Notes</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/03/07/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="next" title="评论系统Valine的使用">
      评论系统Valine的使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Operating-System"><span class="nav-number">1.</span> <span class="nav-text">Operating System</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统功能和定义"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">操作系统功能和定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统定义"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">操作系统定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统的特性"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">操作系统的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作系统历史"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">操作系统历史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分时技术与分时操作系统"><span class="nav-number">1.0.0.5.</span> <span class="nav-text">分时技术与分时操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分时系统的特点"><span class="nav-number">1.0.0.5.1.</span> <span class="nav-text">分时系统的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UNIX"><span class="nav-number">1.0.0.5.2.</span> <span class="nav-text">UNIX</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#典型操作系统类型"><span class="nav-number">1.0.0.6.</span> <span class="nav-text">典型操作系统类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#微机系统"><span class="nav-number">1.0.0.6.1.</span> <span class="nav-text">微机系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实时操作系统"><span class="nav-number">1.0.0.6.2.</span> <span class="nav-text">实时操作系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#嵌入式"><span class="nav-number">1.0.0.6.3.</span> <span class="nav-text">嵌入式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#网络操作系统"><span class="nav-number">1.0.0.6.4.</span> <span class="nav-text">网络操作系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统评价指标"><span class="nav-number">1.0.1.</span> <span class="nav-text">操作系统评价指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统逻辑结构"><span class="nav-number">1.0.2.</span> <span class="nav-text">操作系统逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#整体式"><span class="nav-number">1.0.2.0.1.</span> <span class="nav-text">整体式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#层次式"><span class="nav-number">1.0.2.0.2.</span> <span class="nav-text">层次式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux内核"><span class="nav-number">1.0.2.0.3.</span> <span class="nav-text">Linux内核</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#微内核-客户-服务器结构"><span class="nav-number">1.0.2.0.4.</span> <span class="nav-text">微内核(客户&#x2F;服务器结构)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU的态"><span class="nav-number">1.0.3.</span> <span class="nav-text">CPU的态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU态"><span class="nav-number">1.0.4.</span> <span class="nav-text">CPU态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户态和核态的相互转换"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">用户态和核态的相互转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件和OS对CPU的观察"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">硬件和OS对CPU的观察</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Intel-CPU的态"><span class="nav-number">1.0.4.2.1.</span> <span class="nav-text">Intel CPU的态</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储程序和数据的部件"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">存储程序和数据的部件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分级存储系统的工作原理"><span class="nav-number">1.0.4.3.1.</span> <span class="nav-text">分级存储系统的工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断机制"><span class="nav-number">1.0.5.</span> <span class="nav-text">中断机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断的一些基本概念"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">中断的一些基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断响应过程"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">中断响应过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中断响应的实质"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">中断响应的实质</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统用户界面"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统用户界面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统启动过程"><span class="nav-number">1.1.1.</span> <span class="nav-text">操作系统启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统BIOS"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">系统BIOS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主启动记录"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">主启动记录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MBR-硬盘分区-格式化"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">MBR&#x2F;硬盘分区&#x2F;格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#BIOS和MBR程序运行过程"><span class="nav-number">1.1.1.2.1.1.</span> <span class="nav-text">BIOS和MBR程序运行过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的启动"><span class="nav-number">1.1.2.</span> <span class="nav-text">操作系统的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始引导"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">初始引导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#核心初始化"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">核心初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统初始化"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">系统初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows启动"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">Windows启动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统生成"><span class="nav-number">1.1.3.</span> <span class="nav-text">操作系统生成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主要步骤"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">主要步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OS生成的前提"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">OS生成的前提</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LINUX"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">LINUX</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OS用户界面"><span class="nav-number">1.1.4.</span> <span class="nav-text">OS用户界面</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作界面"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">操作界面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shell脚本编程"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">Shell脚本编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#运行脚本程序的三个方法"><span class="nav-number">1.1.4.2.1.</span> <span class="nav-text">运行脚本程序的三个方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux利用INT-80H中断实现系统调用"><span class="nav-number">1.1.4.3.1.</span> <span class="nav-text">Linux利用INT 80H中断实现系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#隐式系统调用"><span class="nav-number">1.1.4.3.2.</span> <span class="nav-text">隐式系统调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux系统调用的工作原理"><span class="nav-number">1.1.4.3.3.</span> <span class="nav-text">Linux系统调用的工作原理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程管理"><span class="nav-number">1.2.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程概念"><span class="nav-number">1.2.1.</span> <span class="nav-text">进程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的基本概念"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">进程的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进程和程序的区别"><span class="nav-number">1.2.1.1.0.1.</span> <span class="nav-text">　进程和程序的区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的类型"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">进程的类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程状态"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">进程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#支持挂起-suspend-和解挂-resume-操作"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">支持挂起(suspend)和解挂(resume)操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程状态的变迁"><span class="nav-number">1.2.1.2.2.</span> <span class="nav-text">　进程状态的变迁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程控制块-Process-Control-Block"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">进程控制块(Process Control Block)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#PCB的数据结构"><span class="nav-number">1.2.1.3.0.1.</span> <span class="nav-text">PCB的数据结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程的切换"><span class="nav-number">1.2.1.3.1.</span> <span class="nav-text">进程的切换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程控制"><span class="nav-number">1.2.2.</span> <span class="nav-text">进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程创建"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">进程创建</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#创建进程的过程"><span class="nav-number">1.2.2.1.0.1.</span> <span class="nav-text">创建进程的过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程撤销"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">进程撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#撤销的过程"><span class="nav-number">1.2.2.2.0.1.</span> <span class="nav-text">撤销的过程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#进程阻塞"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">进程阻塞</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#阻塞的实现"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">阻塞的实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程唤醒"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">进程唤醒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程控制原语"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">进程控制原语</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows控制进程"><span class="nav-number">1.2.3.</span> <span class="nav-text">Windows控制进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux进程控制"><span class="nav-number">1.2.4.</span> <span class="nav-text">Linux进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#子进程和父进程的并发"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">子进程和父进程的并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fork函数的实现"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">fork函数的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exec函数簇"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">exec函数簇</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">1.2.5.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程概念"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">线程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单线程程序和多线程程序"><span class="nav-number">1.2.5.1.1.</span> <span class="nav-text">单线程程序和多线程程序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程典型应用场景"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">线程典型应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建线程的补充说明"><span class="nav-number">1.2.5.2.1.</span> <span class="nav-text">创建线程的补充说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#临界区和锁"><span class="nav-number">1.2.6.</span> <span class="nav-text">临界区和锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#临界资源和临界区"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">临界资源和临界区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设计临界区访问机制的四个原则"><span class="nav-number">1.2.6.1.1.</span> <span class="nav-text">设计临界区访问机制的四个原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#临界区的大小设置"><span class="nav-number">1.2.6.1.2.</span> <span class="nav-text">临界区的大小设置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁机制"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#上锁操作"><span class="nav-number">1.2.6.2.1.</span> <span class="nav-text">上锁操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开锁操作"><span class="nav-number">1.2.6.2.2.</span> <span class="nav-text">开锁操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁机制访问临界区"><span class="nav-number">1.2.6.2.3.</span> <span class="nav-text">锁机制访问临界区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步和P-V操作-重点"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">同步和P-V操作(重点)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#同步和互斥的概念"><span class="nav-number">1.2.6.3.1.</span> <span class="nav-text">同步和互斥的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P-V操作的概念"><span class="nav-number">1.2.6.3.2.</span> <span class="nav-text">P-V操作的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#信号灯的概念"><span class="nav-number">1.2.6.3.2.1.</span> <span class="nav-text">信号灯的概念</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#信号灯的数据结构"><span class="nav-number">1.2.6.3.2.2.</span> <span class="nav-text">信号灯的数据结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P-V操作解决互斥问题"><span class="nav-number">1.2.6.3.3.</span> <span class="nav-text">P-V操作解决互斥问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P-V操作解决同步问题"><span class="nav-number">1.2.6.3.4.</span> <span class="nav-text">P-V操作解决同步问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Windows和Linux同步机制"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">Windows和Linux同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Windows同步机制"><span class="nav-number">1.2.6.4.1.</span> <span class="nav-text">Windows同步机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Linux父子进程同步"><span class="nav-number">1.2.6.4.2.</span> <span class="nav-text">Linux父子进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#wait函数"><span class="nav-number">1.2.6.4.2.1.</span> <span class="nav-text">wait函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#exit函数"><span class="nav-number">1.2.6.4.2.2.</span> <span class="nav-text">exit函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sleep函数"><span class="nav-number">1.2.6.4.2.3.</span> <span class="nav-text">sleep函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#父子进程共享普通变量"><span class="nav-number">1.2.6.4.2.4.</span> <span class="nav-text">父子进程共享普通变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#父子进程共享文件资源"><span class="nav-number">1.2.6.4.2.5.</span> <span class="nav-text">父子进程共享文件资源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程通信"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Windows中的匿名管道通信"><span class="nav-number">1.2.6.5.1.</span> <span class="nav-text">Windows中的匿名管道通信</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">1.3.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的概念"><span class="nav-number">1.3.1.</span> <span class="nav-text">死锁的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁起因"><span class="nav-number">1.3.2.</span> <span class="nav-text">死锁起因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统资源有限"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">系统资源有限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发进程推进顺序不当"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">并发进程推进顺序不当</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于死锁的一些结论"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">关于死锁的一些结论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预防死锁的策略"><span class="nav-number">1.3.3.</span> <span class="nav-text">预防死锁的策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的必要条件"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">死锁的必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解决死锁的策略"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">解决死锁的策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程调度"><span class="nav-number">1.4.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度概念"><span class="nav-number">1.4.1.</span> <span class="nav-text">进程调度概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调度目标"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">调度目标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#典型进程调度算法"><span class="nav-number">1.4.2.</span> <span class="nav-text">典型进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FCFS-先来先服务"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">FCFS(先来先服务)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SJF-短作业优先调度算法"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">SJF(短作业优先调度算法)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应比高者优先调度"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">响应比高者优先调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先数调度算法"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">优先数调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#静态优先数"><span class="nav-number">1.4.2.4.1.</span> <span class="nav-text">静态优先数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态优先数"><span class="nav-number">1.4.2.4.2.</span> <span class="nav-text">动态优先数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环轮转调度法"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">循环轮转调度法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux进程调度"><span class="nav-number">1.4.3.</span> <span class="nav-text">Linux进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调度时机"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">调度时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程切换"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">进程切换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理"><span class="nav-number">1.5.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理功能"><span class="nav-number">1.5.1.</span> <span class="nav-text">内存管理功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#地址映射"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">地址映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#固定地址映射"><span class="nav-number">1.5.1.1.1.</span> <span class="nav-text">固定地址映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态地址映射"><span class="nav-number">1.5.1.1.2.</span> <span class="nav-text">静态地址映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态地址映射"><span class="nav-number">1.5.1.1.3.</span> <span class="nav-text">动态地址映射.</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟内存"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储保护"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">存储保护</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理内存管理"><span class="nav-number">1.5.2.</span> <span class="nav-text">物理内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分区内存管理"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">分区内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单一区存储管理"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">单一区存储管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分区存储管理"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">分区存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#固定分区"><span class="nav-number">1.5.2.1.2.1.</span> <span class="nav-text">固定分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#动态分区"><span class="nav-number">1.5.2.1.2.2.</span> <span class="nav-text">动态分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#空闲区表如何排序"><span class="nav-number">1.5.2.1.2.3.</span> <span class="nav-text">空闲区表如何排序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#首次适应法"><span class="nav-number">1.5.2.1.2.4.</span> <span class="nav-text"># 首次适应法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#最佳适应法"><span class="nav-number">1.5.2.1.2.5.</span> <span class="nav-text"># 最佳适应法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#最坏适应法"><span class="nav-number">1.5.2.1.2.6.</span> <span class="nav-text"># 最坏适应法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分区的回收"><span class="nav-number">1.5.2.1.3.</span> <span class="nav-text">分区的回收</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存覆盖技术"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">内存覆盖技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存分区"><span class="nav-number">1.5.2.2.1.</span> <span class="nav-text">内存分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#覆盖的缺点"><span class="nav-number">1.5.2.2.2.</span> <span class="nav-text">覆盖的缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存交换技术"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">内存交换技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#交换技术的缺点"><span class="nav-number">1.5.2.3.1.</span> <span class="nav-text">交换技术的缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#需要考虑的问题"><span class="nav-number">1.5.2.3.2.</span> <span class="nav-text">需要考虑的问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存碎片"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">内存碎片</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方法一"><span class="nav-number">1.5.2.4.1.</span> <span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法二-碎片拼接"><span class="nav-number">1.5.2.4.2.</span> <span class="nav-text">方法二: 碎片拼接</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#缺点"><span class="nav-number">1.5.2.4.2.1.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法三-解除程序占用连续内存才能运行的限制"><span class="nav-number">1.5.2.4.3.</span> <span class="nav-text">方法三: 解除程序占用连续内存才能运行的限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟内存管理"><span class="nav-number">1.5.3.</span> <span class="nav-text">虚拟内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#页式虚拟存储管理"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">页式虚拟存储管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页表和页式地址映射"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">页表和页式地址映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#页式地址映射"><span class="nav-number">1.5.3.2.1.</span> <span class="nav-text">页式地址映射</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快表技术和页面共享技术"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">快表技术和页面共享技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺页中断"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">缺页中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面淘汰"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">页面淘汰</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段式和段页式虚拟内存"><span class="nav-number">1.5.4.</span> <span class="nav-text">段式和段页式虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#段式地址映射机制"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">段式地址映射机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段式-VS-页式"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">段式 VS 页式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段页式存储管理"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">段页式存储管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#段页式地址的映射机构"><span class="nav-number">1.5.4.3.1.</span> <span class="nav-text">段页式地址的映射机构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Intel-CPU和-Linux内存管理"><span class="nav-number">1.5.5.</span> <span class="nav-text">Intel CPU和 Linux内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Intel-CPU物理结构"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">Intel CPU物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#实模式"><span class="nav-number">1.5.5.1.1.</span> <span class="nav-text">实模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#保护模式"><span class="nav-number">1.5.5.1.2.</span> <span class="nav-text">保护模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#x86-CPU架构下三种地址"><span class="nav-number">1.5.5.1.3.</span> <span class="nav-text">x86 CPU架构下三种地址</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Intel-CPU段机制"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">Intel CPU段机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#描述符"><span class="nav-number">1.5.5.2.1.</span> <span class="nav-text">描述符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#描述符表"><span class="nav-number">1.5.5.2.2.</span> <span class="nav-text">描述符表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#选择子-Selecto"><span class="nav-number">1.5.5.2.3.</span> <span class="nav-text">选择子(Selecto)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件分页"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">硬件分页</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#普通页表实现问题"><span class="nav-number">1.5.5.3.1.</span> <span class="nav-text">普通页表实现问题:</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux对段的支持"><span class="nav-number">1.5.5.4.</span> <span class="nav-text">Linux对段的支持.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设备管理"><span class="nav-number">1.6.</span> <span class="nav-text">设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设备管理概念"><span class="nav-number">1.6.1.</span> <span class="nav-text">设备管理概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spooling系统"><span class="nav-number">1.6.2.</span> <span class="nav-text">Spooling系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#独占性设备的分配"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">独占性设备的分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享型设备"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">共享型设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟技术"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">虚拟技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SPOOL系统原理"><span class="nav-number">1.6.2.3.1.</span> <span class="nav-text">SPOOL系统原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux模块机制"><span class="nav-number">1.6.3.</span> <span class="nav-text">Linux模块机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#带参数的模块"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">带参数的模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux驱动程序-LDD"><span class="nav-number">1.6.4.</span> <span class="nav-text">Linux驱动程序(LDD)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设备分类"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">设备分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows"><span class="nav-number">1.6.5.</span> <span class="nav-text">Windows</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统"><span class="nav-number">1.7.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件分类"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">文件分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件属性"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">文件属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件系统-1"><span class="nav-number">1.7.0.3.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的逻辑结构"><span class="nav-number">1.7.0.4.</span> <span class="nav-text">文件的逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件存取方法"><span class="nav-number">1.7.0.5.</span> <span class="nav-text">文件存取方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#顺序存取"><span class="nav-number">1.7.0.5.1.</span> <span class="nav-text">顺序存取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#随机存取"><span class="nav-number">1.7.0.5.2.</span> <span class="nav-text">随机存取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件物理结构"><span class="nav-number">1.7.1.</span> <span class="nav-text">文件物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#连续文件"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">连续文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#串联文件"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">串联文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAT文件系统"><span class="nav-number">1.7.2.</span> <span class="nav-text">FAT文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件访问过程"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">文件访问过程:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扇区"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">扇区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#簇-存储块"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">簇 &#x3D; 存储块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件存储和目录"><span class="nav-number">1.7.3.</span> <span class="nav-text">文件存储和目录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#空闲文件目录"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">空闲文件目录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空闲块链"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">空闲块链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位视图"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">位视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件目录管理"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">文件目录管理</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nullptr"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">nullptr</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>




      </div>
      <link rel="stylesheet" href="/dist/APlayer.min.css">
      <div id="aplayer"></div>
      <script type="text/javascript" src="/dist/APlayer.min.js"></script>
      <script type="text/javascript" src="/dist/music.js"></script>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nullptr</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">87k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:19</span>
</div>

<link rel="stylesheet" href="/dist/APlayer.min.css">
      <div id="aplayer"></div>
      <script type="text/javascript" src="/dist/APlayer.min.js"></script>
      <script type="text/javascript" src="/dist/music.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '3iQDsqCTkyy0A3KHhcjtbMk0-gzGzoHsz',
      appKey     : 'RYhztxl3AtsgVo9Lipd0B3WI',
      placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  <link rel="stylesheet" href="/dist/APlayer.min.css">
      <div id="aplayer"></div>
      <script type="text/javascript" src="/dist/APlayer.min.js"></script>
      <script type="text/javascript" src="/dist/music.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
