<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="GCD源码阅读笔记-ONCE篇在使用单例的设计模式时我们常常会使用dispatch_once这个函数来保证单例模式中的单例只会执行一次。那么到底是如何保证只执行一次的呢。 源码版本:libdispatch-1008.200.78">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD源码阅读笔记-ONCE篇">
<meta property="og:url" content="http://yoursite.com/2021/06/01/GCD%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-ONCE%E7%AF%87/index.html">
<meta property="og:site_name" content="Island">
<meta property="og:description" content="GCD源码阅读笔记-ONCE篇在使用单例的设计模式时我们常常会使用dispatch_once这个函数来保证单例模式中的单例只会执行一次。那么到底是如何保证只执行一次的呢。 源码版本:libdispatch-1008.200.78">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-31T16:36:52.000Z">
<meta property="article:modified_time" content="2021-06-01T01:58:42.361Z">
<meta property="article:author" content="nullptr">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/06/01/GCD%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-ONCE%E7%AF%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>GCD源码阅读笔记-ONCE篇 | Island</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
  <div class="container use-motion">
    <div class="headband"></div>
    
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Island</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-messages">

    <a href="/message/" rel="section"><i class="fa fa-fw fa-comment"></i>留言板</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Godlowd" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/06/01/GCD%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-ONCE%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="nullptr">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Island">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GCD源码阅读笔记-ONCE篇
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-01 00:36:52" itemprop="dateCreated datePublished" datetime="2021-06-01T00:36:52+08:00">2021-06-01</time>
            </span>

          
            <span id="/2021/06/01/GCD%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-ONCE%E7%AF%87/" class="post-meta-item leancloud_visitors" data-flag-title="GCD源码阅读笔记-ONCE篇" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/01/GCD%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-ONCE%E7%AF%87/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/01/GCD%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-ONCE%E7%AF%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="GCD源码阅读笔记-ONCE篇"><a href="#GCD源码阅读笔记-ONCE篇" class="headerlink" title="GCD源码阅读笔记-ONCE篇"></a>GCD源码阅读笔记-ONCE篇</h1><p>在使用单例的设计模式时我们常常会使用<code>dispatch_once</code>这个函数来保证单例模式中的单例只会执行一次。那么到底是如何保证只执行一次的呢。</p>
<p><strong>源码版本</strong>:<code>libdispatch-1008.200.78</code></p>
<a id="more"></a>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>在GCD的源码之中使用了非常多的宏，下面简单记录一下后面的源代码中会用到的一些宏定义</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __GNUC__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_EXPECT(x, v) __builtin_expect((x), (v))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_compiler_barrier()  __asm__ __volatile__(<span class="meta-string">""</span> ::: <span class="meta-string">"memory"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_EXPECT(x, v) (x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_compiler_barrier()  do &#123; &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这段宏主要是定义了<code>DISPATCH_EXPECT(x, v)</code>以及<code>dispatch_compiler_barrier()</code>。<code>__builtin_expect</code>函数原型：<code>long __builtin_expect (long EXP, long C)</code>，函数返回值是<code>EXP</code>的值。</p>
<p><code>__GNUC</code>__是用来判断当前编译器是否是采用了<code>GCC</code>的编译器，在这里我们这个地方条件为真，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> likely(x)       __builtin_expect(!!(x), 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlikely(x)     __builtin_expect(!!(x), 0)</span></span><br></pre></td></tr></table></figure>
<p><code>likely</code>和<code>unlikely</code>两个宏定义主要是帮助编译器在进行分支选择时进行优化，避免跳转分支使用的<code>jmp</code>指令带来的开销，详见参考文献<code>likely() and unlikely()</code>。只有当x非常非常非常可能的时候应该使用<code>likely</code>，相对的，只有当x非常非常不可能的时候应该使用<code>unlikely</code>。同理，上面的<code>DISPATCH_EXPECT</code>在<code>GCC</code>条件下也有这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__x86_64__) || defined(__i386__) || defined(__s390x__)</span><br><span class="line">#define DISPATCH_ONCE_INLINE_FASTPATH 1</span><br><span class="line">#elif defined(__APPLE__)</span><br><span class="line">#define DISPATCH_ONCE_INLINE_FASTPATH 1</span><br><span class="line">#else</span><br><span class="line">#define DISPATCH_ONCE_INLINE_FASTPATH 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>根据当前的架构(x86/64,i386等)，定义宏<code>DISPATCH_ONCE_INLINE_FASTPATH</code>。因为函数是在iPhone上调用的，所以当然这个宏的值也就为1了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __has_builtin(__builtin_assume)</span><br><span class="line">#define DISPATCH_COMPILER_CAN_ASSUME(expr) __builtin_assume(expr)</span><br><span class="line">#else</span><br><span class="line">#define DISPATCH_COMPILER_CAN_ASSUME(expr) ((void)(expr))</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这里出现了几个函数<code>__has_builtin</code>,<code>__builtin_assume</code>。<code>Clang</code>的官方文档中解释如下:</p>
<blockquote>
<h3 id="builtin-assume"><a href="#builtin-assume" class="headerlink" title="__builtin_assume"></a><code>__builtin_assume</code></h3><p><code>__builtin_assume</code> is used to provide the optimizer with a boolean invariant that is defined to be true.</p>
<p><strong>Syntax</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_assume(bool)</span><br></pre></td></tr></table></figure>
<p><strong>Example of Use</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int foo(int x) &#123;</span><br><span class="line">__builtin_assume(x !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The optimizer may short-circuit this check using the invariant.</span><br><span class="line">if (x &#x3D;&#x3D; 0)</span><br><span class="line"> return do_something();</span><br><span class="line"></span><br><span class="line">return do_something_else();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Description</strong>:</p>
<p>The boolean argument to this function is defined to be true. The optimizer may analyze the form of the expression provided as the argument and deduce from that information used to optimize the program. If the condition is violated during execution, the behavior is undefined. The argument itself is never evaluated, so any side effects of the expression will be discarded.</p>
<p>Query for this feature with <code>__has_builtin(__builtin_assume)</code>.</p>
</blockquote>
<p>简单来说，编译器默认<code>__builtin_assume</code>的参数是<code>true</code>，并且如果在后面需要对参数进行判断的话可以直接简化，如果参数在后面的过程中不再是<code>true</code>则不知道会发生啥。想知道支不支持这个feature可以通过<code>__has_builtin(__builtin_assume)</code>来判断。</p>
<h2 id="dispatch-once源代码"><a href="#dispatch-once源代码" class="headerlink" title="dispatch_once源代码"></a>dispatch_once源代码</h2><p>我们首先来看<code>dispatch_once_t</code>的定义</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @typedef dispatch_once_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @abstract</span></span><br><span class="line"><span class="comment"> * A predicate for use with dispatch_once(). It must be initialized to zero.</span></span><br><span class="line"><span class="comment"> * Note: static and global variables default to zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DISPATCH_SWIFT3_UNAVAILABLE(<span class="string">"Use lazily initialized globals instead"</span>)</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="built_in">dispatch_once_t</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>dispatch_once_t</code>实际上是一个<code>long</code>，并且是一个必须被初始化为0，这里应该是默认采用了静态变量和全局变量的初始值默认是0的特性。</p>
<p>再来看<code>dispatch_once</code>函数的定义</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @function dispatch_once</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @abstract</span></span><br><span class="line"><span class="comment"> * Execute a block once and only once.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param predicate</span></span><br><span class="line"><span class="comment"> * A pointer to a dispatch_once_t that is used to test whether the block has</span></span><br><span class="line"><span class="comment"> * completed or not.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param block</span></span><br><span class="line"><span class="comment"> * The block to execute once.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @discussion</span></span><br><span class="line"><span class="comment"> * Always call dispatch_once() before using or testing any variables that are</span></span><br><span class="line"><span class="comment"> * initialized by the block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BLOCKS__</span></span><br><span class="line">API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>))</span><br><span class="line">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class="line">DISPATCH_SWIFT3_UNAVAILABLE(<span class="string">"Use lazily initialized globals instead"</span>)</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *predicate,</span><br><span class="line">		DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_INLINE_FASTPATH</span></span><br><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class="line">DISPATCH_SWIFT3_UNAVAILABLE(<span class="string">"Use lazily initialized globals instead"</span>)</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_<span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *predicate,</span><br><span class="line">		DISPATCH_NOESCAPE dispatch_block_t block)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) &#123;</span><br><span class="line">		<span class="built_in">dispatch_once</span>(predicate, block);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dispatch_compiler_barrier();</span><br><span class="line">	&#125;</span><br><span class="line">	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~<span class="number">0</span>l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> dispatch_once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_once _dispatch_once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_ONCE_INLINE_FASTPATH</span></span></span><br></pre></td></tr></table></figure>
<p>回忆使用<code>dispatch_once</code>函数的时候两个参数一个是<code>dispatch_once_t</code>的标志位，另一个是只调用一次的block，因此需要架构支持block的语法，所以在最开始利用宏定义判断是否支持了block。然后在这层判断分支之中又有另外一个判断，判断当前的架构是否支持<code>inline</code>，而在之前<strong>宏定义</strong>一节中提到了这个宏，在<code>Apple</code> 的架构下这个宏是为真的，因此定义了另外一个函数<code>_dispatch_once</code>，并且利用宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> dispatch_once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_once _dispatch_once</span></span><br></pre></td></tr></table></figure>
<p>将<code>dispatch_once</code>和<code>_dispatch_once</code>做了一个替换。也就意味着我们调用<code>dispatch_once</code>实际上是先调用了<code>_dispatch_once</code>，在<code>_dispatch_once</code>函数内部再去调用原来<code>dispatch_once</code>函数的实现。下面继续深入<code>_dispatch_once</code>函数内部。</p>
<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="_dispatch_once"></a>_dispatch_once</h3><p>核心代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_once(<span class="keyword">dispatch_once_t</span> *predicate,</span><br><span class="line">		DISPATCH_NOESCAPE <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0l</span>) != ~<span class="number">0l</span>) &#123;</span><br><span class="line">		dispatch_once(predicate, block);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dispatch_compiler_barrier();</span><br><span class="line">	&#125;</span><br><span class="line">	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~<span class="number">0l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数首先检查传入的标志位是否是<code>~0l</code>，至于为什么是这个值后面会谈。如果判断通过，执行<code>dispatch_once</code>的代码，否则调用函数<code>dispatch_compiler_barrier()</code>，即<strong>内存屏障</strong>。两步结束之后调用<code>DISPATCH_COMPILER_CAN_ASSUME</code>进行编译器优化。</p>
<h3 id="dispatch-once-1"><a href="#dispatch-once-1" class="headerlink" title="dispatch_once"></a>dispatch_once</h3><p>核心代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_once(dispatch_once_t *val, dispatch_block_t block)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>dispatch_once</code>函数实际上只是对<code>dispatch_once_f</code>做了一层封装,<code>_dispatch_Block_invoke</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_Block_invoke(bb) \</span></span><br><span class="line">		((<span class="keyword">dispatch_function_t</span>)((struct Block_layout *)bb)-&gt;invoke)</span><br></pre></td></tr></table></figure>
<p>在文件<code>Block_private.h</code>中，有对<code>Block_layout</code>这个结构体的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count</span></span><br><span class="line">    <span class="keyword">int32_t</span> reserved; </span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>invoke</code>只是这个block的一个方法。继续查看<code>dispatch_once_f</code>函数的定义和实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">API_AVAILABLE(macos(<span class="number">10.6</span>), ios(<span class="number">4.0</span>))</span><br><span class="line">DISPATCH_EXPORT DISPATCH_NONNULL1 DISPATCH_NONNULL3 DISPATCH_NOTHROW</span><br><span class="line">DISPATCH_SWIFT3_UNAVAILABLE(<span class="string">"Use lazily initialized globals instead"</span>)</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once_f(<span class="keyword">dispatch_once_t</span> *predicate, <span class="keyword">void</span> *_Nullable context,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> function);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_INLINE_FASTPATH</span></span><br><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL1 DISPATCH_NONNULL3</span><br><span class="line">DISPATCH_NOTHROW</span><br><span class="line">DISPATCH_SWIFT3_UNAVAILABLE(<span class="string">"Use lazily initialized globals instead"</span>)</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_once_f(<span class="keyword">dispatch_once_t</span> *predicate, <span class="keyword">void</span> *_Nullable context,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> function)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0l</span>) != ~<span class="number">0l</span>) &#123;</span><br><span class="line">		dispatch_once_f(predicate, context, function);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dispatch_compiler_barrier();</span><br><span class="line">	&#125;</span><br><span class="line">	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~<span class="number">0l</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> dispatch_once_f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_once_f _dispatch_once_f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_ONCE_INLINE_FASTPATH</span></span></span><br></pre></td></tr></table></figure>
<p>和上面的<code>dispatch_once</code>与<code>_dispatch_once</code>一样，在<strong>APPLE</strong>架构的前提下<code>dispatch_once_f</code>也被宏定义替换成了<code>_dispatch_once_f</code>。<code>_dispatch_once_f</code>函数体的内容也几乎和<code>_dispatch_once</code>的内容几乎一样，在保证多线程安全的前提下对<code>dispatch_once_f</code>的封装。</p>
<h3 id="dispatch-once-f"><a href="#dispatch-once-f" class="headerlink" title="dispatch_once_f"></a>dispatch_once_f</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once_f(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_once_gate_t</span> l = (<span class="keyword">dispatch_once_gate_t</span>)val;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_ONCE_INLINE_FASTPATH || DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> v = os_atomic_load(&amp;l-&gt;dgo_once, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(v == DLOCK_ONCE_DONE)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">if</span> (likely(DISPATCH_ONCE_IS_GEN(v))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_mark_done_if_quiesced(l, v);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_callout(l, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_once_wait(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数首先对传入的标志值进行了一个转型，<code>dispatch_once_gate_t</code>的定义在<code>lock.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_gate_s</span> &#123;</span></span><br><span class="line">	dispatch_lock dgl_lock;</span><br><span class="line">&#125; dispatch_gate_s, *<span class="keyword">dispatch_gate_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_once_gate_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		dispatch_gate_s dgo_gate;</span><br><span class="line">		<span class="keyword">uintptr_t</span> dgo_once;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; dispatch_once_gate_s, *<span class="keyword">dispatch_once_gate_t</span>;</span><br></pre></td></tr></table></figure>
<p>可知<code>dispatch_once_gate_t</code>实际上是一个指向结构体<code>dispatch_once_gate_s</code>的指针。结构体<code>dispatch_once_gate_s</code>的唯一成员变量是一个联合体。<code>dispatch_gate_s</code>的定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> dispatch_lock;</span><br></pre></td></tr></table></figure>
<p>通过<code>sizeof()</code>函数获得<code>uint32_t</code>和<code>uintptr_t</code>的大小结果如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-31</span> <span class="number">08</span>:<span class="number">17</span>:<span class="number">36.645814</span>+<span class="number">0800</span> testProject[<span class="number">7093</span>:<span class="number">262381</span>]  the <span class="built_in">size</span> of <span class="keyword">uint32_t</span> is <span class="number">4</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-31</span> <span class="number">08</span>:<span class="number">17</span>:<span class="number">36.645906</span>+<span class="number">0800</span> testProject[<span class="number">7093</span>:<span class="number">262381</span>]  the <span class="built_in">size</span> of <span class="keyword">uintptr_t</span> is <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><code>uintptr_t</code>是一个指向int类型的指针，其长度就是平台的字长，<code>uint32_t</code>顾名思义，用来存储32位的int类型的数。A系列处理器和Mac上的处理器现如今都是64位，因此会出现一个比另一个长的缘故。采用联合体来设计不知道当时是否考虑了跨平台的因素。继续往下看。</p>
<p>出现了另一个之前没有的宏定义<code>DISPATCH_ONCE_USE_QUIESCENT_COUNTER</code>，其宏定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__x86_64__) || defined(__i386__) || defined(__s390x__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __APPLE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>__APPLE__</code>架构下这个宏的值为1，再结合之前提过的<code>DISPATCH_ONCE_INLINE_FASTPATH</code>为1,那么就需要执行宏定义if后面的代码块，又是一个没见过的函数<code>os_atomic_load</code>，从函数名来看，似乎是操作系统原子性的加载数据，查看其在文件中的定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_load(p, m) \</span></span><br><span class="line">		atomic_load_explicit(_os_atomic_c11_atomic(p), memory_order_##m)</span><br></pre></td></tr></table></figure>
<p>在<code>cppreference.com</code>中对<code>atomic_load_explicit</code>函数有详细的描述：</p>
<blockquote>
<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><div class="table-container">
<table>
<thead>
<tr>
<th>obj</th>
<th>-</th>
<th>pointer to the atomic object to modify</th>
</tr>
</thead>
<tbody>
<tr>
<td>order</td>
<td>-</td>
<td>the memory synchronization ordering for this operation: only <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">std::memory_order_relaxed</a>, <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">std::memory_order_consume</a>, <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">std::memory_order_acquire</a> and <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">std::memory_order_seq_cst</a> are permitted.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a>Return value</h3><p>The value that is held by the atomic object pointed to by <code>obj</code></p>
</blockquote>
<p>大意就是根据传入参数<code>order</code>，以不同的方式返回<code>obj</code>指向的原子对象。这里涉及到C++11的六种<code>memory order</code>，希望以后有机会再细聊。</p>
<p>原子性加载完V的值后判断<code>dgo_once</code>是否是<code>DLOCK_ONCE_DONE</code>，猜测在完成<code>dispatch_once</code>第一次执行后中这个标志位会被标记成<code>DLOCK_ONCE_DONE</code>，这里有个优化小细节，使用了<code>likely</code>来优化指令排列顺序，因为执行这段代码<code>dgo_once</code>指令的值是<code>DLOCK_ONCE_DONE</code>的概率要远高于其他情况。</p>
<h4 id="dispatch-once-gate-tryenter"><a href="#dispatch-once-gate-tryenter" class="headerlink" title="_dispatch_once_gate_tryenter"></a>_dispatch_once_gate_tryenter</h4><p>我们先跳转到<code>_dispatch_once_gate_tryenter</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_once_gate_tryenter(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_atomic_cmpxchg(&amp;l-&gt;dgo_once, DLOCK_ONCE_UNLOCKED,</span><br><span class="line">			(<span class="keyword">uintptr_t</span>)_dispatch_lock_value_for_self(), relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOCK_GATE_UNLOCKED	((dispatch_lock)0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOCK_ONCE_UNLOCKED	((uintptr_t)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOCK_ONCE_DONE		(~(uintptr_t)0)</span></span><br></pre></td></tr></table></figure>
<p><code>os_atomic_cmpxchg</code>的定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_cmpxchg(p, e, v, m) \</span></span><br><span class="line">		(&#123; _os_atomic_basetypeof(p) _r = (e); \</span><br><span class="line">		atomic_compare_exchange_strong_explicit(_os_atomic_c11_atomic(p), \</span><br><span class="line">		&amp;_r, v, memory_order_##m, memory_order_relaxed); &#125;)</span><br></pre></td></tr></table></figure>
<p>其内部就是<code>atomic_compare_exchange_strong_explicit</code>函数，这个函数的作用是：第二个参数与第一个参数值比较，如果相等，第三个参数的值替换第一个参数的值。如果不相等，把第一个参数的值赋值到第二个参数上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_lock</span><br><span class="line">_dispatch_lock_value_for_self(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_lock_value_from_tid(_dispatch_tid_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_lock</span><br><span class="line">_dispatch_lock_value_from_tid(dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> tid &amp; DLOCK_OWNER_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOCK_OWNER_MASK			((dispatch_lock)0xfffffffc)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_tid_self()		((dispatch_tid)_dispatch_thread_port())</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_thread_port() ((mach_port_t)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> !DISPATCH_USE_THREAD_LOCAL_STORAGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_DIRECT_TSD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_thread_port() ((mach_port_t)(uintptr_t)\</span></span><br><span class="line">		_dispatch_thread_getspecific(_PTHREAD_TSD_SLOT_MACH_THREAD_SELF))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_thread_port() pthread_mach_thread_np(_dispatch_thread_self())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>顺藤摸瓜下来，函数<code>_dispatch_once_gate_tryenter</code>的核心功能就是判断当前的gate的<code>dog_once</code>是不是等于<code>DLOCK_ONCE_UNLOCKED</code>，如果是，把<code>dog_once</code>的值设置成这个线程的<code>pid</code>。</p>
<h4 id="dispatch-once-callout"><a href="#dispatch-once-callout" class="headerlink" title="_dispatch_once_callout"></a>_dispatch_once_callout</h4><p>假如现在确实没有上锁的话，会返回函数<code>_dispatch_once_callout</code>,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_callout(<span class="keyword">dispatch_once_gate_t</span> l, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取到当前队列，执行func</span></span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_once_gate_broadcast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_gate_broadcast(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_lock value_self = _dispatch_lock_value_for_self();</span><br><span class="line">	<span class="keyword">uintptr_t</span> v;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	v = _dispatch_once_mark_quiescing(l);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	v = _dispatch_once_mark_done(l);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (likely((dispatch_lock)v == value_self)) <span class="keyword">return</span>;</span><br><span class="line">	_dispatch_gate_broadcast_slow(&amp;l-&gt;dgo_gate, (dispatch_lock)v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>_dispatch_once_mark_done</code>的名字和实现中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span></span><br><span class="line">_dispatch_once_mark_done(<span class="keyword">dispatch_once_gate_t</span> dgo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_atomic_xchg(&amp;dgo-&gt;dgo_once, DLOCK_ONCE_DONE, <span class="built_in">release</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以了解到这里就是相当于标记之前的block/函数已经执行完成，标记成执行结束。再来看<code>_dispatch_once_mark_quiescing</code>的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span></span><br><span class="line">_dispatch_once_mark_quiescing(<span class="keyword">dispatch_once_gate_t</span> dgo)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_atomic_xchg(&amp;dgo-&gt;dgo_once, _dispatch_once_generation(), <span class="built_in">release</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将<code>dgo_once</code>设置成了<code>_dispatch_once_generation()</code>函数返回值，回忆之前我们跳过的部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">	<span class="keyword">if</span> (likely(DISPATCH_ONCE_IS_GEN(v))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_once_mark_done_if_quiesced(l, v);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_ONCE_MAKE_GEN(gen)  (((gen) &lt;&lt; 2) + DLOCK_FAILED_TRYLOCK_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_ONCE_IS_GEN(gen)    (((gen) &amp; 3) == DLOCK_FAILED_TRYLOCK_BIT)</span></span><br></pre></td></tr></table></figure>
<p>在我们第一次执行完block后，<code>dgo_once</code>的二进制值的低两位变成了<code>DLOCK_FAILED_TRYLOCK_BIT</code>，那么显而易见另外一个执行这个代码的线程就会转到<code>_dispatch_once_mark_done_if_quiesced</code>函数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_once_mark_done_if_quiesced(<span class="keyword">dispatch_once_gate_t</span> dgo, <span class="keyword">uintptr_t</span> gen)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//防止两次生成的时间间隔过短</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_once_generation() - gen &gt;= DISPATCH_ONCE_GEN_SAFE_DELTA) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * See explanation above, when the quiescing counter approach is taken</span></span><br><span class="line"><span class="comment">		 * then this store needs only to be relaxed as it is used as a witness</span></span><br><span class="line"><span class="comment">		 * that the required barriers have happened.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		os_atomic_store(&amp;dgo-&gt;dgo_once, DLOCK_ONCE_DONE, relaxed);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-once-wait"><a href="#dispatch-once-wait" class="headerlink" title="_dispatch_once_wait"></a>_dispatch_once_wait</h3><p>之前一直聊的都是程序判断通过顺序执行的情况，注意到在<code>_dispatch_once_f</code>函数中如果在最后一步获取锁失败的话会返回函数<code>_dispatch_once_wait</code>，根据OS中锁<strong>忙则等待</strong>的思想，猜测这个函数也是大致相似的功能，下面是其源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_once_wait(<span class="keyword">dispatch_once_gate_t</span> dgo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//获取当前线程的锁</span></span><br><span class="line">	dispatch_lock self = _dispatch_lock_value_for_self();</span><br><span class="line">	<span class="keyword">uintptr_t</span> old_v, new_v;</span><br><span class="line">	dispatch_lock *lock = &amp;dgo-&gt;dgo_gate.dgl_lock;</span><br><span class="line">	<span class="keyword">uint32_t</span> timeout = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//无限for循环</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		os_atomic_rmw_loop(&amp;dgo-&gt;dgo_once, old_v, new_v, relaxed, &#123;</span><br><span class="line">      <span class="comment">//是否锁已经被释放</span></span><br><span class="line">			<span class="keyword">if</span> (likely(old_v == DLOCK_ONCE_DONE)) &#123;</span><br><span class="line">				os_atomic_rmw_loop_give_up(<span class="keyword">return</span>);</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">//__APPLE__架构下</span></span><br><span class="line">#<span class="keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span><br><span class="line">			<span class="keyword">if</span> (DISPATCH_ONCE_IS_GEN(old_v)) &#123;</span><br><span class="line">				os_atomic_rmw_loop_give_up(&#123;</span><br><span class="line">					os_atomic_thread_fence(acquire);</span><br><span class="line">					<span class="keyword">return</span> _dispatch_once_mark_done_if_quiesced(dgo, old_v);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">#endif</span><br><span class="line">      <span class="comment">//loop循环两次之后自动break</span></span><br><span class="line">			new_v = old_v | (<span class="keyword">uintptr_t</span>)DLOCK_WAITERS_BIT;</span><br><span class="line">			<span class="keyword">if</span> (new_v == old_v) os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(_dispatch_lock_is_locked_by((dispatch_lock)old_v, self))) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">"trying to lock recursively"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_UL_UNFAIR_LOCK</span></span><br><span class="line">    <span class="comment">//等待锁</span></span><br><span class="line">		_dispatch_unfair_lock_wait(lock, (dispatch_lock)new_v, <span class="number">0</span>,</span><br><span class="line">				DLOCK_LOCK_NONE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> HAVE_FUTEX</span></span><br><span class="line">    <span class="comment">//等待锁</span></span><br><span class="line">		_dispatch_futex_wait(lock, (dispatch_lock)new_v, <span class="literal">NULL</span>,</span><br><span class="line">				FUTEX_PRIVATE_FLAG);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//切换到别的线程</span></span><br><span class="line">		_dispatch_thread_switch(new_v, flags, timeout++);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		(<span class="keyword">void</span>)timeout;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define os_atomic_rmw_loop(p, ov, nv, m, ...)  (&#123; \</span><br><span class="line">		bool _result &#x3D; false; \</span><br><span class="line">		typeof(p) _p &#x3D; (p); \</span><br><span class="line">		ov &#x3D; os_atomic_load(_p, relaxed); \</span><br><span class="line">		do &#123; \</span><br><span class="line">			__VA_ARGS__; \</span><br><span class="line">			_result &#x3D; os_atomic_cmpxchgvw(_p, ov, nv, &amp;ov, m); \</span><br><span class="line">		&#125; while (os_unlikely(!_result)); \</span><br><span class="line">		_result; \</span><br><span class="line">	&#125;)</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;os_atomic_cmpxchgvw函数定义</span><br><span class="line">  #define os_atomic_cmpxchgvw(p, e, v, g, m) \</span><br><span class="line">		(&#123; _os_atomic_basetypeof(p) _r &#x3D; (e); _Bool _b &#x3D; \</span><br><span class="line">		atomic_compare_exchange_weak_explicit(_os_atomic_c11_atomic(p), \</span><br><span class="line">		&amp;_r, v, memory_order_##m, memory_order_relaxed); *(g) &#x3D; _r;  _b; &#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Parameters</strong><br>obj<br>Pointer to an atomic object.<br>Type A represents other overloaded atomic types (if the library does not implement the C-style atomic types as instantiations of atomic).<br>expected<br>Pointer to an object whose value is compared to the contained value, and which -in case it doesn’t match- may be overwritten with the contained value.<br>T is the type of the value contained in the atomic object (atomic’s template parameter).<br>val<br>Value to copy to the contained object in case expected matches the contained value.<br>T is the type of the value contained in the atomic object (atomic’s template parameter).<br>success<br>Synchronization mode for the operation in case expected matches the contained value.<br>This shall be a value of the enum type memory_order.<br>failure<br>Synchronization mode for the operation in case expected does not match the contained value.<br>This shall be a value of the enum type memory_order that is neither memory_order_release nor memory_order_acq_rel, and which is not stronger than success.</p>
<p><strong>Return value</strong><br>true if *expected compares equal to the contained value (and does not fail spuriously).<br>false otherwise.</p>
</blockquote>
<p>注意到<code>os_atomic_rmw_loop</code>函数的参数是可变的，同时在<code>do</code>语句块中有一个<code>__VA_ARGS__;</code>，结合无限for循环的最后一个参数的具体内容可知，就是在这个地方判断锁的状态。注意到，在loop语句块的最后用<code>old_v</code>与<code>DLOCK_WAITERS_BIT</code>做了一个或操作并赋给<code>new_v</code>。循化两次之后后面的if语句就会判断为真，退出当前的loop。这里这样处理是为了避免长时间卡在一个地方，因为还需要判断后面的锁有没有，如果有则需要进入后面的锁等待中，如<code>UL_UNFAIR_LOCK</code>,<code>FUTEX</code>。如果这两种锁也都没有则切换到其他的线程，注意到这里的切换的新线程的<code>mach_port_id</code>是<code>new_v</code>，但是这个<code>new_v</code>并不一定与一个实际存在的线程对应。但是没有关系，调度器早就帮我们想好了这一点，即时不与一个实际的线程对应，调度器还是会切换到当前可切换的其他线程上运行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们重新梳理一遍<code>dispatch_once</code>这个函数的执行流程。在<code>__APPLE__</code>架构下,<code>DISPATCH_ONCE_INLINE_FASTPATH</code>和<code>DISPATCH_ONCE_USE_QUIESCENT_COUNTER</code>都是1。<code>dispatch_once</code>和<code>dispatch_once_f</code>也只是因为有了<code>block</code>语法对<code>dispatch_once_f</code>的一层封装。</p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>第一次执行代码的情况下，<code>dispatch_once_t</code>标志位<code>val</code>被转型成<code>dispatch_once_gate_s</code>的结构体<code>l</code>，<code>l-&gt;dgo_once</code>的值必然不可能是<code>DLOCK_ONCE_DONE</code>，<code>DISPATCH_ONCE_IS_GEN</code>返回的值必然不可能为真。因此会直接跳转到<code>_dispatch_once_gate_tryenter</code>，因为是第一次执行，<code>val</code>的所有值均为0，因此<code>l-&gt;dgo_once</code>的值也就是<code>DLOCK_ONCE_UNLOCKED</code>判断通过，判断通过紧跟着的就是上锁（用当前线程的<code>pid</code>代替锁的标志）。上锁完成后即调用只执行一次的代码。代码块执行完成进行开锁操作，调用<code>_dispatch_once_generation()</code>函数修改<code>l-&gt;dgo_once</code>的值，如此一来，下一次线程执行再调用<code>dispatch_once</code>的代码在<code>DISPATCH_EXPECT</code>就可以直接判断调用过然后返回。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>假定有线程A和线程B两个线程同时执行<code>dispatch_once</code>。</p>
<p>两个线程同时执行到<code>if (_dispatch_once_gate_tryenter(l))</code>语句处，假定线程A先执行判断语句，正如刚才提到的，线程A会对修改<code>l-&gt;dgo_once</code>的值并且是原子操作，线程B执行这段代码时就会返回<code>False</code>因为数据已经被上锁。线程A和单线程的情况一样一直顺序执行，进入函数<code>_dispatch_once_callout</code>；线程B因为无法获取锁执行函数<code>dispatch_once_wait</code>，在无限循环中请求锁。当线程A完成操作，并进行广播，即执行函数<code>_dispatch_once_mark_quiescing</code>，线程B在循环中得知<code>DISPATCH_ONCE_IS_GEN</code>，或者从休眠中被唤醒，调用函数，修改<code>l-&gt;dgo_once</code>的值为<code>DONE</code>。退出循环。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.babyitellyou.com/details?id=5fd0fa08f8d82b7f220427dd" target="_blank" rel="noopener">iOS 多线程知识体系构建(十)：GCD 源码：dispatch_once、dispatch_semaphore函数</a>(这篇文章讲的不错，推荐)<br><a href="https://blog.csdn.net/weixin_40918107/article/details/109520980" target="_blank" rel="noopener">OC底层探索(二十一)GCD异步、GCD同步、单例、信号量、调度组、栅栏函数等底层分析</a><br><a href="https://kernelnewbies.org/FAQ/LikelyUnlikely" target="_blank" rel="noopener">likely() and unlikely()</a><br><a href="https://clang.llvm.org/docs/LanguageExtensions.html" target="_blank" rel="noopener">__builtin_assume</a><br><a href="https://opensource.apple.com/source/libclosure/libclosure-63/Block_private.h" target="_blank" rel="noopener">Block_private.h</a><br><a href="https://en.cppreference.com/w/cpp/atomic/atomic_load" target="_blank" rel="noopener">atomic_load</a><br><a href="https://www.cplusplus.com/reference/atomic/atomic_compare_exchange_strong_explicit/" target="_blank" rel="noopener">atomic_compare_exchange_strong_explicit</a><br><a href="http://www.cplusplus.com/reference/atomic/atomic_compare_exchange_weak_explicit/" target="_blank" rel="noopener">atomic_compare_exchange_weak_explicit</a><br><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/thread_switch.html" target="_blank" rel="noopener">thread_switch</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"><i class="fa fa-tag"></i> iOS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/15/Objective-C%20Block%E7%9A%84%E5%AE%9E%E8%B4%A8/" rel="prev" title="Objective-C Block的实质">
      <i class="fa fa-chevron-left"></i> Objective-C Block的实质
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/01/os-unfair-lock-lock%E4%B8%8EOSSpinLock/" rel="next" title="os_unfair_lock_lock与OSSpinLock">
      os_unfair_lock_lock与OSSpinLock <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GCD源码阅读笔记-ONCE篇"><span class="nav-number">1.</span> <span class="nav-text">GCD源码阅读笔记-ONCE篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#宏定义"><span class="nav-number">1.1.</span> <span class="nav-text">宏定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#builtin-assume"><span class="nav-number">1.1.1.</span> <span class="nav-text">__builtin_assume</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-once源代码"><span class="nav-number">1.2.</span> <span class="nav-text">dispatch_once源代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-once"><span class="nav-number">1.2.1.</span> <span class="nav-text">_dispatch_once</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-once-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">dispatch_once</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-once-f"><span class="nav-number">1.2.3.</span> <span class="nav-text">dispatch_once_f</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parameters"><span class="nav-number">1.2.4.</span> <span class="nav-text">Parameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Return-value"><span class="nav-number">1.2.5.</span> <span class="nav-text">Return value</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-once-gate-tryenter"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">_dispatch_once_gate_tryenter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-once-callout"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">_dispatch_once_callout</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-once-wait"><span class="nav-number">1.2.6.</span> <span class="nav-text">_dispatch_once_wait</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单线程"><span class="nav-number">1.3.1.</span> <span class="nav-text">单线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程"><span class="nav-number">1.3.2.</span> <span class="nav-text">多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">1.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="nullptr"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">nullptr</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>




      </div>
      <link rel="stylesheet" href="/dist/APlayer.min.css">
      <div id="aplayer"></div>
      <script type="text/javascript" src="/dist/APlayer.min.js"></script>
      <script type="text/javascript" src="/dist/music.js"></script>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nullptr</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">87k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:19</span>
</div>

<link rel="stylesheet" href="/dist/APlayer.min.css">
      <div id="aplayer"></div>
      <script type="text/javascript" src="/dist/APlayer.min.js"></script>
      <script type="text/javascript" src="/dist/music.js"></script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@latest/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : '3iQDsqCTkyy0A3KHhcjtbMk0-gzGzoHsz',
      appKey     : 'RYhztxl3AtsgVo9Lipd0B3WI',
      placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  <link rel="stylesheet" href="/dist/APlayer.min.css">
      <div id="aplayer"></div>
      <script type="text/javascript" src="/dist/APlayer.min.js"></script>
      <script type="text/javascript" src="/dist/music.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
